---
title: 几种鉴权方案
date: 2021-03-31 11:13:10
tags:
- 前端
- 安全
categories:
- 前端
---

> 鉴权也叫身份验证（Authentication），是指验证用户是否拥有访问系统的权利。在日常的生活中，身份验证随处可见，比如：进入高铁站候车室、机场候机楼需要检查票据和身份证件；游玩主题乐园、名胜风景区需要购买门票，并由入口处人员鉴定有效后方可拥有进入园区游玩的权利。

面试时提到但经常叙述不清，开个专栏记录下。

<!-- more -->

## Session-Cookie

同时在服务端设置session以及浏览器端设置cookie；

session可以保存在内存中，也可以保存在redis；

首次访问时在服务端创建session，该session有一个唯一的标识字符串，然后再set-cookie中设置该唯一字符串（sid）；session的内容包括用户角色、登录时间等。

服务器接受客户端请求时解析cookie中的sid，然后去寻找有无对应session，判断该请求是否合法。

中间可以对sid进行加密处理（签名）

[阮一峰-数字签名是什么](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)

弊端：session消耗服务器内存

cookie容易受到CSRF攻击

## Token

![Token 认证流程图](http://img.mrsingsing.com/authentication-token-authencation.jpg)

#### 流程：

1. 用户输入登录信息并请求登录
2. 服务端收到请求，验证用户输入的登录信息
3. 验证成功后，服务端会 `签发`一个 Token（通常包含用户基础信息、权限范围和有效时间等），并把这个 Token 返回给客户端
4. 客户端收到 Token 后需要把它存储起来，比如放在 localStorage 或 sessionStorage 里（**一般不放 Cookie** 因为可能会有跨域问题，以及安全性问题）
5. 后续客户端每次向服务端请求资源的时候，将 Token 附带于 HTTP 请求头 **Authorization** 字段中发送请求
6. 服务端收到请求后，去校验客户端请求中 Token，如果验证成功，就向客户端返回请求的数据，否则拒绝返还（返回401）

#### 优点：

- **服务端无状态**：Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在**多个服务器**间共享用户状态
- 支持**移动设备**（因为移动设备没有cookie）
- 支持**跨域跨程序**调用，因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题
- 有效避免 CSRF 攻击（因为不需要 Cookie），但是会存在 XSS 攻击中被盗的风险，但是可选择 Token 存储在标记为 `httpOnly` 的 Cookie 中，能够有效避免浏览器中的 JS 脚本对 Cookie 的修改

缺点：

- 占带宽：正常情况下比 `sid` 更大，消耗更多流量，挤占更多宽带。（几乎可以忽略）
- 性能问题：相比较于 Session-Cookie 认证来说，Token 需要服务端花费更多时间和性能来对 Token 进行解密验证，其实 Token 相较于 Session—Cookie 来说就是一个**时间换空间**的方案
- 由于服务器不保存session,因此一旦签发就无法修改权限,及有效期限;
- 为了减少盗用机会,JWT不应该使用http,应该使用https

## JWT

[阮一峰-JWT入门](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

服务器认证后生成一个JSON对象，签名后发送回用户；

结构：

`Header.Payload.Signature`

#### Header

是一个完整的JSON对象

header描述JST的**元数据**，包括`alg`：**签名**使用的算法，`typ`表示token类型；使用时用**base64UR**L转化成字符串

#### Payload

也是一个JSON对象，用来存放实际要传递的数据

JWT提供了7个官方字段：

```json
iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
```

也可以定义私用字段；

也用**base64URL**转成字符串

#### Signature

使用Header中指定的算法进行签名；

```json
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

#### Base64和Base64URL

> 前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。
>
> JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所以要被替换掉：`=`被省略、`+`替换成`-`，`/`替换成`_` 。这就是 Base64URL 算法。

优缺点同上述token;

#### 主动让JWT失效的方法

> 目前常见的处理方法有:
>
> - 1,将 token 存入 DB（如 Redis）中，失效则删除；但增加了一个每次校验时候都要先从 DB 中查询 token是否存在的步骤，而且违背了 JWT 的无状态原则（不推荐）。
> - 2,维护一个 token 黑名单，失效则加入黑名单中(用的比较多)。
> - 3,在 JWT 中增加一个版本号字段，失效则改变该版本号。
> - 4,在服务端设置加密的 key 时，为每个用户生成唯一的 key，失效则改变该 key。

其中,124都需要**在服务器存储状态**,3利用JWT可以**传输数据**的特点;

实际工程中2使用比较多,开销比较小

