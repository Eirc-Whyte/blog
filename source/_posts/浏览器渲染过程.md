---
title: 浏览器渲染过程
date: 2021-03-16 23:05:09
tags:
- 前端
- 浏览器渲染
categories:
- 工程开发
---

导航过程完成之后，浏览器进程把数据交给了渲染进程，渲染进程负责tab内的所有事情，核心目的就是将HTML/CSS/JS代码，转化为用户可进行交互的web页面。那么渲染进程是如何工作的？面试中被问到无数次的问题，系统学习下。

<!--more-->





### 渲染进程

渲染进程包括：

- 主线程
- 多个工作线程
- 一个合成器线程
- 多个光栅化线程

### 构建DOM

收到来自网络进程的数据以及浏览器进程的渲染请求后，渲染进程开始解析数据，将其转化为DOM对象。

### 子资源加载

构建DOM的过程中，若解析到CSS/JS/图片等资源，需要从网络/缓存中获取。

为了提升效率，浏览器也会运行**预加载扫描程序**，如果HTML中存在`img`、`link`、`script`等标签，预加载扫描程序会把这些请求传递给`Browser Process`的network thread进行资源**下载**。

### JavaScript的下载与执行

构建DOM过程中，如果遇到`<script>`标签，渲染引擎会停止对HTML的解析，而去加载执行JS代码，原因在于JS代码可能会改变DOM的结构（比如执行`document.write()`等API）

但如果开发者明确知道自己的脚本不会改变dom，那么可以字形添加async或者defer属性，浏览器就会异步加载和执行JS代码，而不阻塞渲染。

#### defer&async区别

没有时：

![没有标记 defer 或 async 时](https://beginor.github.io/assets/post-images/without-defer-async-head.png)

标记defer时：

![标记 defer 时](https://beginor.github.io/assets/post-images/with-defer.png)

标记async时：

![标记 async 时](https://beginor.github.io/assets/post-images/with-async.png)

通用做法：放到底部

![在 body 的最尾部](https://beginor.github.io/assets/post-images/without-defer-async-body.png)

### 样式计算（CSSOM树构建）

DOM树只是页面的结构，而没有节点的样式。浏览器根据**层叠**和**继承**规则进行每个节点样式的构建。

> `继承`：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫`UserAgent样式`。
>
> `层叠`：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。某种意义上，它处于核心地位，具体的层叠规则属于深入 CSS 语言的范畴。

计算的结果可以从`document.styleSheet`看到，也就是通常意义上指的CSSOM。

### 布局

上述已经完成DOM以及样式计算，接下来主线程会遍历DOM以及相关元素的样式，计算出包含**每个元素页面位置坐标信息**以及**盒模型大小的**布局树（render tree）。遍历过程中会跳过隐藏的元素（display:none），对于不可见的节点，head,meta标签等都会被忽略。。另外，伪元素在布局树上是可见的。

![image-20210323131334972](https://ericblog.oss-cn-beijing.aliyuncs.com/img/image-20210323131334972.png)



### 绘制

在绘制阶段，主线程会遍历布局树（layout tree），每次都会把一个复杂的图层拆分为很小的**绘制指令**，然后再按照这些指令的顺序组成一个**绘制列表**。绘制列表准备好了之后，渲染进程的主线程会给`合成线程`发送`commit`消息，把绘制列表提交给合成线程。

### 合成

合成是一种将**页面分成若干层**，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。

![合成过程](https://ericblog.oss-cn-beijing.aliyuncs.com/img/1460000022634006.gif)

通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**

- 显式合成：

  元素有了**层叠上下文的属性**或者**需要被剪裁**，满足其中任意一点，就会被提升成为单独一层。

- 隐式合成：

  `z-index`比较低的节点会提升为一个单独的途图层，那么`层叠等级比它高`的节点**都会**成为一个独立的图层。（可能会导致层爆炸）



图层很大时，没有必要一次绘制出全部的图层，因此合成线程将会把图层分块，有了图块之后，合成线程会按照**视口附近的图块**来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。生成的位图被保存在 GPU 内存中。

![渲染进程](https://ericblog.oss-cn-beijing.aliyuncs.com/img/20210323131520.png)

当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做**绘画四边形**（draw quads）的信息来构建一个**合成帧**（compositor frame）。

- 绘画四边形：包含图块在**内存的位置**以及图层合成后图块在页面的位置之类的信息。
- 合成帧：代表页面一个帧的内容的绘制四边形**集合**。

以上所有步骤完成后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。

合成的好处在于这个过程**没有涉及到主线程**，所以合成线程**不需要**等待样式的计算以及JavaScript完成执行。这就是为什么[合成器相关的动画](https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/)最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。

### PS：回流 重绘 合成

#### 回流

另外一个叫法是重排，回流触发的条件就是:**对 DOM 结构的修改引发 DOM 几何尺寸变化的时候**,会发生`回流`过程。

![img](https://ericblog.oss-cn-beijing.aliyuncs.com/img/1732ec388e85bd2d.png)

#### 重绘

当页面中元素样式的改变并不影响它在文档流中的**位置**时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

![img](https://ericblog.oss-cn-beijing.aliyuncs.com/img/1732ec3b24ec43c9.png)

跳过了`布局树`和`建图层树`,直接去绘制列表，然后在去分块,生成位图等一系列操作。

**可以看到，重绘不一定导致回流，但回流一定发生了重绘。**

#### 合成

还有一种情况：就是**更改了一个既不要布局也不要绘制**的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的**合成**操作，这个过程就叫**合成**。

CSS的transform来实现动画效果，**避免了回流跟重绘**，直接在非主线程中执行合成动画操作。显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以**相对于重绘和重排，合成能大大提升绘制效率。**

提升合成层的最好方式是使用 CSS 的 will-change 属性

利用 CSS3 的`transform`、`opacity`、`filter`这些属性就可以实现合成的效果，也就是大家常说的**GPU加速**。



## 参考：

[前端都该懂的浏览器工作原理，你懂了吗？](https://segmentfault.com/a/1190000022633988)

[「浏览器工作原理」写给女友的秘籍-渲染流程篇（1.1W字）](https://juejin.cn/post/6847902222349500430#heading-26)

