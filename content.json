{"pages":[],"posts":[{"title":"CF Round# 625 (div2)","text":"跟kkgg的cf康复赛（1/n） 多年不打cf了，依稀记得上次打还是高中某个不写作业的晚上顶着困到空白的脑子怼英文题面。 T1 Contest for Robots题目描述两个机器人答题，已知n场比赛机器人的胜负情况，通过安排每场比赛的分数可以让机器人”Robo-Coder Inc.”恰好胜过机器人”BionicSolver Industries”。（“恰好”的定义为R比B的最终得分多1分）问这样安排中一场比赛分数可能的最小的最高分数能安排多少。 思路描述在某场比赛上： R赢B输，则R比B多挣这场比赛的分数 R输B赢，则R比B少挣这场比赛的分数 RB同输同赢，不影响最终比赛结果。 记$$Score_{R} = R赢B输的比赛分数和\\Score_{B} = B赢R输的比赛分数和$$那么只要控制$Score_{R} = Score_{B}+ 1$ 即可恰好使R胜利。 因为要求最小，所以$Score_{B}$的各场比赛分数必然是1分，那么$Score_{R} = \\lceil \\frac{Score_{B}+1}{Bwin} \\rceil = \\frac{Score_{B}}{Bwin}+1$ T2 Journey Planning题目描述有n个城市，每个城市的下标为$c_{i}$，并且每个城市有一个beauty值，每到达一个城市之后选择下一个城市必须满足约束条件：$c_{i+1}-c_{i} = b_{c_{i+1}}-b_{c_{i}}$才能到达。问如何选择才能获得最大的总beauty值，并输出最大值。 思路描述按着题目看了半天才看懂意思，其实就是一个简单的公式变换题目，跟顺序并无卵关系。 把约束条件稍微变一下就成了$c_{i+1}-b_{c_{i+1}} = c_{i}-b_{i}$ 意思就是：把每个城市下标减去beauty值相同的扔一个桶里，最后找到最大的就可。 当然，可能会减出负数，注意补上beauty的最大值。 T3 Remove Adjacent题目描述给定一个字符串$s$，其中字符$s_{i}$可以被移除当且仅当相邻的字符是$s_{i}$的previous letter。例如b的previous letter 是a，c的previous letter是b以此类推。第一个和最后一个字符只有一个相邻的字符，其他位置的字符均有两个相邻字符。问给定的字符串最多可以移除多少个字符。 思路描述一开始以为是个搜索，仔细想了想并不是，因为previous letter的定义决定了从z到a移除一定是最佳的。 如果从中间开始移除，例如在abc里先移除b，那么c显然移除不了。所以直接贪心写就可。 需要注意的是，当在串中找某个字符并移除后，可能有相同的字符依然符合移除条件，那么就继续移除直到不能移除为止，再进行下一个字符的寻找。 T4 Navigation Systemtag：最短路 T5 World of Darkraft: Battle for Azathothtag：two pointers 、前缀和 T6 Reachable Stringstag：hash 最终结果（3/6）错误小结： 写了if到底写不写else，这是一个问题 减法下标溢出，cmp里不开long long","link":"/2020/03/03/CF-Round-625-div2/"},{"title":"DeepLearning.ai by Andrew Ng","text":"使用Word Embeding利用已经训练好的WordEmbedding数据集可以进行迁移学习 Transfer learning and word embeddings： 自己训练（网上下载）embedding 将embedding迁移到需要训练的数据集上 选择：如果新数据集很大，可以继续使用新数据调整embedding。 广泛用于基本的NLP任务 relation to face encoding： face encoding ：test是不可预知的 word embedding ： test是已知的（词汇表中的所有单词） 词嵌入的特性通过两词向量之差距离判断相似$$e_{man} - e_{woman} = \\left[\\begin{array}[l]-2 \\0\\0\\\\vdots\\end{array}\\right] \\approx e_{king} - e_{queen}$$其实是在高维空间形成的向量相似 那么就是要找一个单词$w$$$argmax_w\\ \\ similarity(e_w,e_{king}-e_{man}+e_{women})$$cosine similarity：$$similarity(u,v) = \\frac{u^Tv}{||u||_2||v||_2}$$ Embedding matrix$$EO_{6257} = e_{6257}$$ $O_{6257}$是第6257号词的one-hot向量，$e_{6257}$是第6257号词的embedding向量，$E$是Embedding matrix，即词汇表中所有单词的embedding向量组合。 Embedding Methods朴素的：前几个单词的OneHot*Embedding matrix 作为参数，接入NN，然后由softmax函数输出字典中每个单词的可能性。 Word2Vec","link":"/2020/09/30/DeepLearning-ai-by-Andrew-Ng/"},{"title":"Csp-M1","text":"CSP-M1最后一题写炸，220滚粗（ T1 咕咕东的奇遇题目描述咕咕东是个贪玩的孩子，有一天，他从上古遗迹中得到了一个神奇的圆环。这个圆环由字母表组成首尾相接的环，环上有一个指针，最初指向字母a。咕咕东每次可以顺时针或者逆时针旋转一格。例如，a顺时针旋转到z，逆时针旋转到b。咕咕东手里有一个字符串，但是他太笨了，所以他来请求你的帮助，问最少需要转多少次。 输入格式输入只有一行，是一个字符串。 输出格式输出最少要转的次数。 问题分析单纯模拟，假设c为当前所在字母，s[i]为目标字母，每次答案加上短弧即可 $min(abs(c-s[i]),26-abs(c-s[i]))$ 代码123456789101112int main(){ string s; cin&gt;&gt;s; char c = 'a'; int ans =0; for(int i = 0;i&lt;s.size();i++){ ans += min(abs(c-s[i]),26-abs(c-s[i])); c = s[i]; } cout&lt;&lt;ans; return 0;} T2 咕咕东想吃饭题目描述咕咕东考试周开始了，考试周一共有n天。他不想考试周这么累，于是打算每天都吃顿好的。他决定每天都吃生煎，咕咕东每天需要买$a_i$个生煎。但是生煎店为了刺激消费，只有两种购买方式：①在某一天一次性买两个生煎。②今天买一个生煎，同时为明天买一个生煎，店家会给一个券，第二天用券来拿。没有其余的购买方式，这两种购买方式可以用无数次,但是咕咕东是个节俭的好孩子，他训练结束就走了，不允许训练结束时手里有券。咕咕东非常有钱，你不需要担心咕咕东没钱，但是咕咕东太笨了，他想问你他能否在考试周每天都能恰好买$a_i$个生煎。 输入格式输入两行，第一行输入一个正整数n(1&lt;=n&lt;=100000)(1&lt;=n&lt;=100000)，表示考试周的天数。 第二行有n个数，第i个数a_i（0&lt;=a_i&lt;=10000）ai（0&lt;=ai&lt;=10000）表示第i天咕咕东要买的生煎的数量。 输出格式如果可以满足咕咕东奇怪的要求，输出”YES”，如果不能满足，输出“NO”。（输出不带引号） 问题分析 样例可以抽象为上面这种方块，那么我们可以将问题转化为：有两种取法（红蓝），问能不能将方块取完。 可以采取贪心策略：从左到右按列取，对于每列： 如果是奇数，则采取n蓝色取法+1\\红色取法（后面一列方块数量-1） 如果是偶数，则采取n*蓝色取法 除了最后一列，前面的列按上述方法必然可以取完。如果遇到不够减的情况则必然无法达到要求。 对每一列处理，最后检查最后一列是否为奇数即可。 代码123456789101112131415161718192021const int maxx = 100010;int t[maxx];int main(){ int n ; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;t[i]; } for(int i = 1;i&lt;=n;i++){ if(t[i]%2 == 1){ if(t[i+1] == 0){ cout&lt;&lt;\"NO\"; return 0; }else t[i+1]--; }else{ t[i] = 0; } } cout&lt;&lt;\"YES\"; return 0;} T3 可怕的宇宙射线问题描述有一个射线，每次可以向左右45°方向分裂，问射线最终能覆盖到多少个位置。 输入描述第一行一个正整数n表示分裂次数$(n\\leq 30)$ 第二行n个正整数，表示每次分裂后直线传播的长度($a_i\\leq 5$) 输出描述一个数ans表示有多少个位置被覆盖 样例说明 问题分析 表面上题目的数据范围十分巨大2^30，实际上每次分裂仅走5，分裂三十次的话，射线最远仅能覆盖到300*300的范围。 那么我们可以直接用搜索，bfs dfs均可，只要剪枝剪的好，没啥搜索过不了（雾。 考虑同次分裂产生的射线有可能形成“T”字重合，这种情况可以剪掉。 再进一步，对于我们记flag[300][300][30][8]​为图上某点的状态值，30为最大分裂次数，8为方向。也就是说，对于从同一次分裂产生的同方向的射线，我们是完全不用重复遍历的，可以通过记录这个状态给他剪掉。 但是即使是不同方向的射线经过同一个点，这个点最多对答案产生一点贡献，因此需要另开一个无次数无方向，只记录走没走过的数组vis[300][300] 其实还可以再进一步，把分裂次数一维改为：在某方向上剩下要走的单位数，因为如果方向相同+要走的步数相同，就是完全重合的射线了。就可以更大程度上剪枝。但是好像没必要就直接过了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253bool vis[355][355];long long ans;int zx[8] = {0,1,1,1,0,-1,-1,-1};int zy[8] = {1,1,0,-1,-1,-1,0,1};int sum;bool flag[355][355][160][8];int turn[200];int count;struct rec{ int x,y,d,t; rec(int x,int y,int d,int t):x(x),y(y),d(d),t(t){}};void bfs(){ queue&lt;rec&gt; q; rec first(160,160,0,1); q.push(first); while(!q.empty()){ rec h = q.front(); q.pop(); if(h.t &gt; sum || flag[h.x][h.y][h.t][h.d]){ continue; } flag[h.x][h.y][h.t][h.d] = 1; if(!vis[h.x][h.y]){ ans++; vis[h.x][h.y] = 1; } if(!turn[h.t]){ rec nex(h.x + zx[h.d] , h.y + zy[h.d], h.d, h.t+1); q.push(nex); }else{ int d1 = (h.d+1)%8; int d2 = (h.d+7)%8; rec nex1(h.x + zx[d1] , h.y + zy[d1], d1, h.t+1); rec nex2(h.x + zx[d2] , h.y + zy[d2], d2, h.t+1); q.push(nex1); q.push(nex2); } }}int main(){ int n ; cin&gt;&gt;n; int t; for(int i = n;i&gt;=1;i--){ cin&gt;&gt;t; sum += t; turn[sum] = 1; } bfs(); cout&lt;&lt;ans; return 0;}","link":"/2020/03/20/Csp-M1/"},{"title":"ES6学习笔记","text":"参考阮一峰《ES6标准入门》 let &amp; constES6新增let命令，它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效，没有变量提升。 变量提升：var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。 暂时性死区 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 块级作用域fix了ES5中只有全局和函数作用域而没有块级作用域带来的不合理场景。 例如： 1234567891011// 内层变量覆盖外层变量：var tmp = new Date();function f() { console.log(tmp); if (false) { var tmp = 'hello world'; }}f(); // undefined 以及 12345678// 循环变量泄露为全局变量var s = 'hello';for (var i = 0; i &lt; s.length; i++) { console.log(s[i]);}console.log(i); // 5 ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 constconst保证的是：const变量指向内存中的数据不得改动。 因此对于简单类型有效，对于复杂类型（对象，数组）仅能保证指针不变。 123456const foo = {}foo.prop = 123;// okfoo = {};// TypeError 可以用Object.freeze()将对象冻结，使其不可添加新属性。 要将属性也冻结，可以递归调用Object.freeze: 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; 变量解构赋值类似于Python的解构赋值 可以这样 1let [a, b, c] = [1, 2, 3] 这样 1let [foo, [[bar], baz]] = [1, [[2], 3]]; 以及这样 1let [head, ...tail] = [1, 2, 3, 4]; 前提：右边是可遍历结构（有Iterator）；只要等号右边的值不是对象或数组，就先将其转为对象。（null/undefined不能转化为对象） 允许指定默认值： 1let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，当且仅当右边变量严格等于undefined，默认值才生效。null不是undefined。 对象解构赋值时要求属性名严格相等 Promise 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 async &amp; awaitasync函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 12345678910111213const gen = function* () { const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());};&lt;==&gt;const asyncReadFile = async function () { const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());};","link":"/2021/02/23/ES6/"},{"title":"EdWordle笔记","text":"Edwordle项目主要算法学习笔记 摘要Edwordle允许用户在保持与其他单词的邻居关系时移动编辑单词，提出了可保持邻居关系的Wordle算法，并将其与带约束的刚体力学系统结合，来构造更加紧密的词云布局。 EdWordle After the wordle is loaded, we first apply a customized rigid body dynamics approach, which helps us to make the layout more compact while preserving the neighborhood relationships 首先使用customized rigid body dynamics方法将零散的单词进行紧密化。 To do so, after each step the rigid body dynamics step is automatically invoked again 在用户移动完某个单词之后，重新使用该方法保持单词的紧密性。 At any time, the result can be further improved by performing a Re-Wordle 使用local-wordle-layout方法进行优化。 All steps are based on our two-level box representation for the words, which allows us to create compact representations without words squeezing in between characters of other larger words. 所有的操作都基于two-level box representation两级矩形表示法来构建单词刚体，使得编辑过程中可以保持单词位置的连贯性以及无重叠。 Rigid Body Dynamic Based Layouttodos Two-level box representation&amp;customized external forces approachtodos local Wordle layouttodos","link":"/2021/03/31/EdWordle笔记/"},{"title":"Monthly simulation - March","text":"模拟题真就模拟题 201512-3题目描述本题要求编程实现一个用 ASCII 字符来画图的程序，支持以下两种操作：  画线：给出两个端点的坐标，画一条连接这两个端点的线段。简便起见题目保证要画的每条线段都是水平或者竖直的。水平线段用字符 - 来画，竖直线段用字符 | 来画。如果一条水平线段和一条竖直线段在某个位置相交，则相交位置用字符 + 代替。  填充：给出填充的起始位置坐标和需要填充的字符，从起始位置开始，用该字符填充相邻位置，直到遇到画布边缘或已经画好的线段。注意这里的相邻位置只需要考虑上下左右 4 个方向， 输入第1行有三个整数m, n和q。m和n分别表示画布的宽度和高度，以字符为单位。q表示画图操作的个数。 第2行至第q + 1行，每行是以下两种形式之一：  0 x1 y1 x2 y2：表示画线段的操作，(x1, y1)和(x2, y2)分别是线段的两端，满足要么x1 = x2 且y1 ≠ y2，要么 y1 = y2 且 x1 ≠ x2。  1 x y c：表示填充操作，(x, y)是起始位置，保证不会落在任何已有的线段上；c 为填充字符，是大小写字母。 画布的左下角是坐标为 (0, 0) 的位置，向右为x坐标增大的方向，向上为y坐标增大的方向。这q个操作按照数据给出的顺序依次执行。画布最初时所有位置都是字符 .（小数点）。 输出输出有n行，每行m个字符，表示依次执行这q个操作后得到的画图结果。 问题分析 应该支持两个操作：画线段和填充。画线段直接循环即可，填充操作类似油漆桶，可用bfs或者dfs. 画线段时要注意”+”的条件：画“|”时，如果遇到“-”则画“+”，否则，如果不是“+”则画“|”。画“-”亦然。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int m,n,q;char mp[300][300];int zx[4] = {0,1,-1,0}, zy[4] = {-1,0,0,1};void draw(int x,int y,char c){ if(mp[x][y] == '-' || mp[x][y] == '+' || mp[x][y] == '|'){ return; } mp[x][y] = c; for(int i = 0;i&lt;4;i++){ int tx = x + zx[i]; int ty = y + zy[i]; if(tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt; n &amp;&amp; ty &lt; m &amp;&amp; mp[tx][ty] != c){ draw(tx,ty,c); } }}int main(){ cin&gt;&gt;m&gt;&gt;n&gt;&gt;q; for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ mp[i][j] = '.'; } } for(int i = 1;i&lt;=q;i++){ int op; cin&gt;&gt;op; switch(op){ case 0:{ int x1,x2,y1,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; if(x1 == x2){ if(y1&gt;y2)swap(y1,y2); for(int j = y1;j&lt;=y2;j++){ if(mp[j][x1] == '-') mp[j][x1] = '+'; else if(mp[j][x1] != '+') mp[j][x1] = '|'; } }else { if(x1&gt;x2)swap(x1,x2); for(int j = x1;j&lt;=x2;j++){ if(mp[y1][j] == '|') mp[y1][j] = '+'; else if(mp[y1][j] != '+') mp[y1][j] = '-'; } } break; } case 1:{ int x,y; char c; cin&gt;&gt;y&gt;&gt;x&gt;&gt;c; draw(x,y,c); break; } } } for(int i = n-1;i&gt;=0;i--){ for(int j = 0;j&lt;m;j++){ cout&lt;&lt;mp[i][j]; } cout&lt;&lt;'\\n'; } return 0;} 201604-3题目描述为了指定文件系统中的某个文件，需要用路径来定位。在类 Unix 系统（Linux、Max OS X、FreeBSD等）中，路径由若干部分构成，每个部分是一个目录或者文件的名字，相邻两个部分之间用 / 符号分隔。 有一个特殊的目录被称为根目录，是整个文件系统形成的这棵树的根节点，用一个单独的 / 符号表示。在操作系统中，有当前目录的概念，表示用户目前正在工作的目录。根据出发点可以把路径分为两类：  绝对路径：以 / 符号开头，表示从根目录开始构建的路径。  相对路径：不以 / 符号开头，表示从当前目录开始构建的路径。 例如，有一个文件系统的结构如下图所示。在这个文件系统中，有根目录 / 和其他普通目录 d1、d2、d3、d4，以及文件 f1、f2、f3、f1、f4。其中，两个 f1 是同名文件，但在不同的目录下。 对于 d4 目录下的 f1 文件，可以用绝对路径 /d2/d4/f1 来指定。如果当前目录是 /d2/d3，这个文件也可以用相对路径 ../d4/f1 来指定，这里 .. 表示上一级目录（注意，根目录的上一级目录是它本身）。还有 . 表示本目录，例如 /d1/./f1 指定的就是 /d1/f1。注意，如果有多个连续的 / 出现，其效果等同于一个 /，例如 /d1///f1 指定的也是 /d1/f1。 本题会给出一些路径，要求对于每个路径，给出正规化以后的形式。一个路径经过正规化操作后，其指定的文件不变，但是会变成一个不包含 . 和 .. 的绝对路径，且不包含连续多个 / 符号。如果一个路径以 / 结尾，那么它代表的一定是一个目录，正规化操作要去掉结尾的 /。若这个路径代表根目录，则正规化操作的结果是 /。若路径为空字符串，则正规化操作的结果是当前目录。 输入第一行包含一个整数 P，表示需要进行正规化操作的路径个数。第二行包含一个字符串，表示当前目录。以下 P 行，每行包含一个字符串，表示需要进行正规化操作的路径。 1234567897/d2/d3/d2/d4/f1../d4/f1/d1/./f1/d1///f1/d1/////d1/../../d2 输出共 P 行，每行一个字符串，表示经过正规化操作后的路径，顺序与输入对应。 1234567/d2/d4/f1/d2/d4/f1/d1/f1/d1/f1/d1//d2 问题分析 直接split('/')就好了啊！让俺瞅瞅cpp的split方法怎么写！Google启动！ 靠c++没有split 那俺自己实现一个，把分割好的扔到vector&lt;string&gt;不就行了 依照题意，遍历一遍处理好的vector，把有内容的都压到新的vector&lt;string&gt;里，忽略内容为空的、内容为.的；遇到..的就把新vectorpop_back()一下，注意不要空弹。 注意有空字符串，因此读入要用getline，不然读不到。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344std::vector&lt;std::string&gt; split(const std::string &amp;s, char delim) { std::vector&lt;std::string&gt; elems; std::stringstream ss(s); std::string item; while (std::getline(ss, item, delim)) { elems.push_back(item); } return elems;}inline void process(std::string s){ std::vector&lt;std::string&gt; st = split(s,'/'); std::vector&lt;std::string&gt; ans; for(auto it = begin(st);it!=end(st);it++){ if((*it) == \".\" || (*it) == \"\") continue; if((*it) == \"..\"){ if(!ans.empty()) ans.pop_back(); }else { ans.push_back((*it)); } } if(ans.empty()) std::cout&lt;&lt;\"/\"; for(auto it = ans.begin();it!=ans.end();it++){ std::cout&lt;&lt;\"/\"&lt;&lt;(*it); } std::cout&lt;&lt;\"\\n\"; return;}int main(){ int n; std::string location; std::cin&gt;&gt;n&gt;&gt;location; std::cin.get(); for(int i = 1;i&lt;=n;i++){ std::string s; getline(std::cin,s); if(s[0] == '/'){ process(s); }else{ s = location + \"/\" + s; process(s); } } return 0;}","link":"/2020/03/20/Monthly-simulation-March/"},{"title":"Mysql+vscode+wsl环境配置","text":"0安装vscode 安装wsl Ubuntu18.04（换源aliyun 安装mysql-server 1先获得root权限 1sudo su wsl中输入 1service mysql start 若出现 1MySQL 5.7 No directory, logging in with HOME=/ then 123service mysql stopusermod -d /var/lib/mysql/ mysqlservice mysql start 其中 /var/lib/mysql/ 处存储的是mysql的日志文件&amp;数据库文件 usermod修改mysql 的登入目录为上述目录 然后可能会显示： 1'Access denied for user 'root'@'localhost' 编辑 /etc/mysql/mysql.conf.d/mysqld.cnf 或者对应的mysql配置文件， 在[mysqld]下面添加： 1skip-grant-tables 再次重启mysql， 1mysql -uroot -p 直接回车跳过密码 12ALTER USER 'root'@'localhost' IDENTIFIED BY mysql_native_password 'password';flush privileges; 重启 1service mysql restart 2vscode安装mysql插件 选择 添加connection 输入password之后connect 即可成功 3常用的mssql插件无法连接wsl 的mysql不知道为啥 反正就是连不上233","link":"/2019/08/18/Mysql+vscode+wsl环境配置/"},{"title":"bind,apply and call","text":"Apply与Call的用途几乎相同，用于明确this指向以及方法借用等场景；Bind用来指定this指向或Currying functions。 Bind（）1function.bind(thisArg[, arg1[, arg2[, ...]]]) thisArg调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg。 arg1, arg2, ...当目标函数被调用时，被预置入绑定函数的参数列表中的参数。 bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 绑定函数将对象的函数与对象绑定，防止在其他环境中（例如window）丢失原本对象。 或者实现thisArg对象对某个其他函数的借用。 12345678910111213141516this.x = 9; // 在浏览器中，this 指向全局的 \"window\" 对象var module = { x: 81, getX: function() { return this.x; }};module.getX(); // 81var retrieveX = module.getX;retrieveX();// 返回 9 - 因为函数是在全局作用域中调用的// 创建一个新函数，把 'this' 绑定到 module 对象// 新手可能会将全局变量 x 与 module 的属性 x 混淆var boundGetX = retrieveX.bind(module);boundGetX(); // 81 偏函数bind() 的另一个最简单的用法是，利用thisArg后的参数arg1,arg2…使一个函数拥有若干预设的初始参数。 CurryCurrying 是这么一种机制，它将一个接收多个参数的函数，拆分成多个接收单个参数的函数。可以视为一种特殊的偏函数。 例如将简单函数add柯里化： 1234567891011121314function add (a, b) { return a + b;}add(3, 4); // returns 7// currying===&gt;function add (a) { return function (b) { return a + b; }}// bind ==&gt;var addCurry = add.bind(null,10);add(12)// 22 more over, 将一般化函数进行 Currying 化： 12345678function curry(f) { return function currify() { const args = Array.prototype.slice.call(arguments); return args.length &gt;= f.length ? // f.length是f的参数个数 f.apply(null, args) : currify.bind(null, ...args) }} 实用价值： 函数的组合 两个函数的组合f(g(x)) 12345var compose = function(f,g) { return function(x) { return f(g(x)); };}; 通过上面的讨论我们知道，任意函数都可经过 Currying 化处理后变成多个只接收单个入参的函数。这就为函数的组合提供了基础。 12const compose = fn1 =&gt; fn2 =&gt; input =&gt; fn1(fn2(input));const myFn = compose(f)(g); 更一般化的组合： 1234567const pipe = (...fns) =&gt; input =&gt; fns.reduce((mem,fn)=&gt; fn(mem),input)const double = x =&gt; x*2const addOne = x =&gt; x + 1const square = x =&gt; x*x// 右倾管道pipe(square, double, addOne)(2) Apply and Call当我们使用 apply 或者 call 时, 传入的第一个参数为目标函数中 this 指向的对象。 apply 和 call 的用法几乎相同, 唯一的差别在于当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量. 除此外, 在 ES6 的箭头函数下, call 和 apply 均失效, 对于箭头函数来说: 函数体内的 this 对象, 就是定义时所在的对象, 而不是使用时所在的对象; 不可以当作构造函数, 也就是说不可以使用 new 命令, 否则会抛出一个错误; 不可以使用 arguments 对象, 该对象在函数体内不存在. 如果要用, 可以用 Rest 参数代替; 不可以使用 yield 命令, 因此箭头函数不能用作 Generator 函数; 既然提到箭头函数，那么—— 箭头函数引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值： 如果是该函数是一个构造函数，this指针指向一个新的对象 在严格模式下的函数调用下，this指向undefined 如果是该函数是一个对象的方法，则它的this指针指向这个对象 setInterval、setTimeout这类函数的this值默认都是window 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。 由于箭头函数没有自己的this，对箭头函数实用call和apply均失效，但是可以bind 箭头函数不绑定arguments对象，因此如果要用arguments，使用剩余参数(...args)是更好的选择 没有prototype、不能使用new和yield，但是可以使用闭包。 Ployfillbind实现方法： 123456789101112131415161718// Does not work with `new (funcA.bind(thisArg, args))`if (!Function.prototype.bind) (function(){ var slice = Array.prototype.slice; Function.prototype.bind = function() { var thatFunc = this, thatArg = arguments[0]; var args = slice.call(arguments, 1); if (typeof thatFunc !== 'function') { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - ' + 'what is trying to be bound is not callable'); } return function(){ var funcArgs = args.concat(slice.call(arguments)) return thatFunc.apply(thatArg, funcArgs); }; };})(); apply实现方法： 12345678910111213141516Function.prototype.myApply = function(context) { if (typeof this !== 'function') { throw new TypeError('Error') } context = context || window context.fn = this let result // 处理参数和 call 有区别 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result}","link":"/2021/03/10/bind-apply-and-call/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/23/hello-world/"},{"title":"mobx-react踩坑","text":"哦吼快看这个托更博主终于更博了（雾） MobX用于简单、可扩展的状态管理。通常搭配 React 使用，但不只限于 React。如何你厌烦了 Redux 繁杂的模板代码和 API，那么可以尝试下 MobX。 前言目前对状态管理非常浅显的理解：状态管理就是把动态页面的每一个“帧”看作一个状态，当发生与用户之间的交互（点击、输入）时，呈现给用户的页面的状态会发生改变（登录成功、加载新页面等）。而react的状态信息可能存储在组件树的各个组件之上，因此如果一次交互需要触发多个不同层级组件的状态刷新时，可能会比较麻烦，因此需要状态管理工具。 扯白了说，react的各个组件就相当于一堆子函数，而且参数只能通过相邻层级进行传递。这对于某些数据而言十分不自然。在C++中，我们自然可以开辟全局变量来解决这种问题，而在react中，由于涉及到与浏览器的交互balabala，比较普遍的解决方案是使用Redux进行状态管理。 但是！Redux的应用场景大多数还是大型应用，写起来比较规（ma）范（fan）。对于数据库课设这种小型应用，可选的还有mobx、dva这种轻量一些的状态管理工具。他们都可以直接在组件树的任意节点访问以及更新状态库store中的数据（状态）。在我的理解中就相当于一个动态的全局变量库。 选择mobx是因为dva的文档看不太懂（雾） 然而mobx也有很多坑，就比如—— issue1：配置babel环境由于mobx普遍采用装饰器语法（其实也可以选择非装饰器语法但是太丑2333）所以需要配上装饰器语法的支持： solution1：使用 customize-cra react-app-rewired由于使用的是官方的create-react-app脚手架，所以如果不能自己直接修改webpack之类 “脚手架”是一种元编程的方法，用于构建基于数据库的应用。许多MVC框架都有运用这种思想。程序员编写一份specification（规格说明书），来描述怎样去使用数据库；而由（脚手架的）编译器来根据这份specification生成相应的代码，进行增、删、改、查数据库的操作。我们把这种模式称为”脚手架”，在脚手架上面去更高效的建造出强大的应用！ 的配置。所以我们使用社区开源的一个修改CRA（CreatReactApp）配置的工具customize-cra 配合react-app-rewired，直接绕过（覆盖）原配置，进行自定义配置。 安装customize-cra react-app-rewired 以及装饰器支持@babel/plugin-proposal-decorators 1yarn add customize-cra react-app-rewired @babel/plugin-proposal-decorators 项目根目录（src的同级目录）新建文件config-overrides.js文件： 1234const { override, addDecoratorsLegacy } = require('customize-cra');module.exports = override( addDecoratorsLegacy() ); 修改package.json文件： 123456\"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-app-rewired eject\" }, solution2：使用npm run eject弹出配置文件进行修改执行完这个命令yarn run eject后会将封装在 CRA 中的配置全部反编译到当前项目，这样用户就可以完全取得 webpack 文件的控制权，想怎么修改就怎么修改了。 CRA 与其他脚手架不同的另一个地方，就是可以通过升级其中的react-scripts包来升级 CRA 的特性。比如用老版本 CRA 创建了一个项目，这个项目不具备 PWA 功能，但只要项目升级了react-scripts包的版本就可以具备 PWA 的功能，项目本身的代码不需要做任何修改。 但如果我们使用了eject命令，就再也享受不到 CRA 升级带来的好处了，因为react-scripts已经是以文件的形式存在于你的项目，而不是以包的形式，所以无法对其升级。 作者：Run丘比特 首先弹出配置 1yarn run eject 安装装饰器扩展 1yarn add babel-plugin-transform-decorators-legacy 修改package.json ( 注意transform-decorators-legacy要放在第一个 ) 12345678\"babel\": { \"plugins\": [ \"transform-decorators-legacy\" ], \"presets\": [ \"react-app\" ]} 然后就解决了装饰器语法的问题，可以开始愉快地使用mobx了。 因为网上很多教程可能都没用CRA构建，所以基本都是只有sulution2的后半部分，没有写明需要弹出配置文件，因此再怎么折腾.balrc都不管用。所以，如果用了CRA脚手架构建react应用时使用mobx（或者其他需要装饰器语法的包时）都要先eject/override一下配置文件才行。 Reference传送门： MobX入门 TodoList Create React App无eject配置 issue2：updateUser is not a function！?这个问题也不知道是啥时候整的历史遗留问题，之前也不知道为啥work，现在突然就不work了让我一顿好找。感谢Chrome的开发者工具，断点调试真香。 其实就是涉及到一个语法错误的问题。 mobx的使用流程大概是： 新建一个observable的store存放状态——在应用入口文件index.js中将其import到文件中——new 一个store——使用Provider组件（context实现）包裹最外层的组件节点，刚刚new 的store作为属性传入——在内层任意一个节点需要时inject到组件中并使用observer装饰器监听被inject状态的变化并重新渲染。 然而我在index.js中new 是这么写的： 123const store = { store:new Store()} 然后还是这么导入： 12345&lt;Provider store={store}&gt; &lt;BrowserRouter&gt; &lt;App/&gt; &lt;/BrowserRouter&gt;&lt;/Provider&gt; 然后访问store的action函数时一直提示： Unhandled Rejection (TypeError): this.props.store.updateUser( ) is Not a function. 找了一万个博客也找不到，一度怀疑是装饰器解释器的问题，但是更换了不用装饰器的方法还是8行。最后在Chrome里瞎搞，在调用函数的前一行打了个断点，然后再到控制台观察它的自动补全内容（tcl），这才发现玄机：this.props.store打印出来是个 {store : UserInfo} 然后this.props.store.store.updateUser是个函数！然后右手就轻轻地落到了自己的脸上（MMMMMMMMP） 最后修改了store的定义： 1const store = new Store() 就好了qwq 预告:react-cookie的使用 待续…","link":"/2020/02/25/mobx-react踩坑/"},{"title":"几种鉴权方案","text":"鉴权也叫身份验证（Authentication），是指验证用户是否拥有访问系统的权利。在日常的生活中，身份验证随处可见，比如：进入高铁站候车室、机场候机楼需要检查票据和身份证件；游玩主题乐园、名胜风景区需要购买门票，并由入口处人员鉴定有效后方可拥有进入园区游玩的权利。 面试时提到但经常叙述不清，开个专栏记录下。 Session-Cookie同时在服务端设置session以及浏览器端设置cookie； session可以保存在内存中，也可以保存在redis； 首次访问时在服务端创建session，该session有一个唯一的标识字符串，然后再set-cookie中设置该唯一字符串（sid）；session的内容包括用户角色、登录时间等。 服务器接受客户端请求时解析cookie中的sid，然后去寻找有无对应session，判断该请求是否合法。 中间可以对sid进行加密处理（签名） 阮一峰-数字签名是什么 弊端：session消耗服务器内存 cookie容易受到CSRF攻击 Token 流程： 用户输入登录信息并请求登录 服务端收到请求，验证用户输入的登录信息 验证成功后，服务端会 签发一个 Token（通常包含用户基础信息、权限范围和有效时间等），并把这个 Token 返回给客户端 客户端收到 Token 后需要把它存储起来，比如放在 localStorage 或 sessionStorage 里（一般不放 Cookie 因为可能会有跨域问题，以及安全性问题） 后续客户端每次向服务端请求资源的时候，将 Token 附带于 HTTP 请求头 Authorization 字段中发送请求 服务端收到请求后，去校验客户端请求中 Token，如果验证成功，就向客户端返回请求的数据，否则拒绝返还（返回401） 优点： 服务端无状态：Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务器间共享用户状态 支持移动设备（因为移动设备没有cookie） 支持跨域跨程序调用，因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题 有效避免 CSRF 攻击（因为不需要 Cookie），但是会存在 XSS 攻击中被盗的风险，但是可选择 Token 存储在标记为 httpOnly 的 Cookie 中，能够有效避免浏览器中的 JS 脚本对 Cookie 的修改 缺点： 占带宽：正常情况下比 sid 更大，消耗更多流量，挤占更多宽带。（几乎可以忽略） 性能问题：相比较于 Session-Cookie 认证来说，Token 需要服务端花费更多时间和性能来对 Token 进行解密验证，其实 Token 相较于 Session—Cookie 来说就是一个时间换空间的方案 由于服务器不保存session,因此一旦签发就无法修改权限,及有效期限; 为了减少盗用机会,JWT不应该使用http,应该使用https JWT阮一峰-JWT入门 服务器认证后生成一个JSON对象，签名后发送回用户； 结构： Header.Payload.Signature Header是一个完整的JSON对象 header描述JST的元数据，包括alg：签名使用的算法，typ表示token类型；使用时用base64URL转化成字符串 Payload也是一个JSON对象，用来存放实际要传递的数据 JWT提供了7个官方字段： 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 也可以定义私用字段； 也用base64URL转成字符串 Signature使用Header中指定的算法进行签名； 1234HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret) Base64和Base64URL 前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 优缺点同上述token; 主动让JWT失效的方法 目前常见的处理方法有: 1,将 token 存入 DB（如 Redis）中，失效则删除；但增加了一个每次校验时候都要先从 DB 中查询 token是否存在的步骤，而且违背了 JWT 的无状态原则（不推荐）。 2,维护一个 token 黑名单，失效则加入黑名单中(用的比较多)。 3,在 JWT 中增加一个版本号字段，失效则改变该版本号。 4,在服务端设置加密的 key 时，为每个用户生成唯一的 key，失效则改变该 key。 其中,124都需要在服务器存储状态,3利用JWT可以传输数据的特点; 实际工程中2使用比较多,开销比较小","link":"/2021/03/31/几种鉴权方案/"},{"title":"建模-主成分分析","text":"主成分分析（PCA）​ 主成分分析（Principal components analysis，以下简称PCA）是最重要的降维方法之一。在数据压缩消除冗余和数据噪音消除等领域都有广泛的应用。一般我们提到降维最容易想到的算法就是PCA。 ​ 顾名思义，PCA就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。具体的，假如我们的数据集是n维的，共有m个数据$(x^{(1)},x^{(2)},…,x^{(m)})$。我们希望将这$m$个数据的维度从$n$维降到$n’$维，希望这$m$个$n’$维的数据集尽可能的代表原始数据集。我们知道数据从n维降到n’维肯定会有损失，但是我们希望损失尽可能的小。那么如何让这$n’$维的数据尽可能表示原来的数据呢？ ​ 我们先看看最简单的情况，也就是$n=2，n’=1$,也就是将数据从二维降维到一维。数据如下图。我们希望找到某一个维度方向，它可以代表这两个维度的数据。图中列了两个向量方向，$u1$和$u2$，那么哪个向量可以更好的代表原始数据集呢？从直观上也可以看出，$u1$比$u2$好。 为什么$u1$比$u2$好呢？可以有两种解释，第一种解释是样本点到这个直线的距离足够近，第二种解释是样本点在这个直线上的投影能尽可能的分开。 假如我们把$n’$从1维推广到任意维，则我们的希望降维的标准为：样本点到这个超平面的距离足够近,或者说样本点在这个超平面上的投影能尽可能的分开。 PCA推导 基于最小投影距离 基于最大投影方差 基于奇异值分解（SVD） PCA流程输入：n维样本集$D=(x^{(1)}, x^{(2)},…,x^{(m)})$，要降维到的维数$n’$. 输出：降维后的样本集$D′$ 1) 对所有的样本进行中心化： $x^{(i)} = x^{(i)} - \\frac{1}{m}\\sum\\limits_{j=1}^{m} x^{(j)}$ 2) 计算样本的协方差矩阵$XX^T$ 3) 对矩阵$XX^T$进行特征值分解 4）取出最大的$n’$个特征值对应的特征向量$(w_1,w_2,…,w_{n’})$ 将所有的特征向量标准化后，组成特征向量矩阵$W$。 5）对样本集中的每一个样本$x^{(i)}$,转化为新的样本$z^{(i)}=W^Tx^{(i)}$ 6) 得到输出样本集$D’ =(z^{(1)}, z^{(2)},…,z^{(m)})$ ​ 有时候，我们不指定降维后的$n’$的值，而是换种方式，指定一个降维到的主成分比重阈值$t$。这个阈值$t$在$(0,1]$之间.假如我们的$n$个特征值为$\\lambda_1 \\geq \\lambda_2 \\geq … \\geq \\lambda_n$,则$n’$可以通过下式得到:$$\\frac{\\sum\\limits_{i=1}^{n’}\\lambda_i}{\\sum\\limits_{i=1}^{n}\\lambda_i} \\geq t$$ PCA优缺点PCA算法的主要优点有： 1）仅仅需要以方差衡量信息量，不受数据集以外的因素影响。 2）各主成分之间正交，可消除原始数据成分间的相互影响的因素。 3）计算方法简单，主要运算是特征值分解，易于实现。 PCA算法的主要缺点有： 1）主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。 2）方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。 参考博客： 主成分分析（PCA）原理总结 从特征分解，奇异值分解到主成分分析","link":"/2020/08/21/建模-主成分分析/"},{"title":"建模-元胞自动机(CA)","text":"元胞自动机（Cellular Automaton）概念看上去很厉害，其实就是一种仿真模型，根据一定的规则，通过上一时刻状态对空间内（通常是二维）的数组变量进行下一状态的推算。 拿一维CA举例： 假设初始状态是（如图）：010010000（每个格子的01随机取定/根据初始化约束确定） 那么从上面初始状态进行一代代迭代就可以得到（黑色表示1，白色表示0）： 不妨将其称为CA三要素： 初始状态 转移规则 结束状态 建模中常用的是二维/三维上的CA，用于模拟一些系统（森林火灾、封闭空间逃生、疾病传播、城镇扩张、洪水演进等）。 btw，对于某个元胞，有两种邻居称呼方式： VonNeumann邻居，即只考虑前后左右的邻居。 Moore邻居，即考虑周边相邻的所有邻居。 有什么用CA通常可以应用于研究系统问题，which由若干不同的对象组成，对象之间可以相互作用，因此适用于一些机理建模的问题中。从上面的简述也可以看出，起决定作用的是转移规则的定义。根据具体问题的不同可以自行定义适合题目要求的规则，并设置一定的迭代次数，在根据题目要求或者直接随机初始化元胞，之后按照迭代次数和转移规则仿真模拟系统在不同时刻（或其他物理量）的变化状况与趋势，最后综合评估系统状况以及转移规则是否合适。 具体应用人员疏散模型：具体参考： 张鑫龙, 陈秀万, 李怀瑜, 李飞. 一种改进元胞自动机的人员疏散模型. 武汉大学学报·信息科学版, 2017, 42(9): 1330-1336. 该模型将社会力模型应用于人员疏散的CA中，社会力模型可表示为： 根据每个元胞受力不同，计算该元胞下一时刻的速度方向及大小变化，从而推算出所有元胞的下一时刻所在位置及状态（速度方向、大小、加速度方向、大小）。 为了将行人（元胞）之间的碰撞情况也纳入考量，该模型将默认元胞自动机“每个元胞占据一个单元格的设定”改为“每个元胞占据四个单元格”，以能够模拟出行人的拥挤状况。 教室逃生模型： 森林火灾模型假如某棵树着火了，那么在cell里的数值，就应当是1，代表这棵树着火了，并且在下一个时刻，这个cell的数值将变成0，代表树烧没了。在森林火灾模型中，规则就是：只要4个邻居cells有一个是1，并且自己是2，那么下个时间节点自己将变成1，再下一个时间节点自己变成0。 有点类似于最著名的生命游戏的规则： 总结可以看到，大多数时候CA只是一种概念，如何在具体问题中去应用CA进行系统分析，才是建模过程中需要认真考虑的问题。 一些想法： 既然多数CA用二维数组实现，是不是可以考虑使用卷积简化运算？ 除了最常用的matlab实现，是否可以考虑使用D3.js等可视化工具让生成的CA更好看？","link":"/2020/08/17/建模-元胞自动机-CA/"},{"title":"建模-数学规划模型-1","text":"线性规划问题 max相当于min$\\times -1$ 最后答案$\\times -1$ 无下限lb取-inf;无上限ub取inf 整数规划问题线性整数规划 线性0-1规划 非线性规划问题 加了一个$c(x)\\leq0$项和一个$Ceq(x)=0$项，其余不变。注意加的两项右边都是0 例子： matlab求解：","link":"/2020/08/27/建模-数学规划模型-1/"},{"title":"建模-无约束优化问题-1","text":"优化问题$$min\\ f(x)\\subject\\ to \\ x\\in\\Omega$$ 其中x是一个n维向量，$\\Omega$ 是约束集（可行域） 形如以上的问题统称为优化问题。 目标：求解函数f在定义域上的全局最小点，但实际上全局最小点很难得到，因此实际应用中通常是找局部最小点。 一维搜索方法 黄金分割法 可用于求解一元单值函数，只使用目标函数值$f$。 思路：挑选区间$[a_0,b_0]$中的点，计算目标函数值，通过比较确定如何缩小区间。一般采用对称压缩方式来缩小极小点所在区间。即：$$a_1-a_0=b_0-b_1=\\rho(b_0-a_0)\\ \\rho&lt; \\frac{1}{2}$$$f(a_1)&lt;f(b_1)$那么极小值点应该在$[a_0,b_1]$中，否则在$[a_1,b_0]$中。（三分法思路） 通过使$\\rho=0.382$可以使每次迭代只需要计算一次$f$值 斐波那契数列方法 如果在上述过程中，不断动态调整$\\rho$，则可以产生一个新的搜索方法，提高压缩比（最终区间更小）。 推导详见最优化导论，下面直接给出结论：$$\\rho_1 = 1-\\frac{F_N}{F_{N+1}}\\\\rho_2 = 1-\\frac{F_{N-1}}{F_N}\\\\rho_k = 1-\\frac{F_{N-k+1}}{F_{N-k+2}}…\\\\rho_N = 1-\\frac{F_1}{F_2}$$需要指出的是，最终的$\\rho_N=\\frac{1}{2}$，因此最后一次迭代的参数需要修正为$\\rho_N=1/2-\\epsilon$. 二分法 可用于求解一元单值函数，只使用目标函数一阶导数值$f$。 二分一阶导数，如果导数&gt;0则说明极小点在左侧，否则在右侧。显而易见的思路。压缩比比上述两个方法都要小。 牛顿法 可用于求解一元单值函数，使用目标函数一阶、二阶导数值，要求函数连续二阶可微。 通过构造函数$q(x)$逐渐逼近使函数$f$一阶导数为0的点。 推导详见最优化导论，下面直接给出结论： 从一初始值$x_0$开始，根据公式$x^{(k+1)}=x^{(k)}-\\frac{f’(x^{(k)})}{f’’(x^{(k)})}$迭代$x$. 牛顿法能够不断迫使目标函数的一阶导数趋向于0 。当牛顿法用于求解方程$g(x) = 0$时，牛顿法又叫牛顿切线法，也就是我们小学二年级就学过的牛顿法估计求函数零点。 划界法 上述方法均需要一个初始区间/点作为迭代开始，寻找这一初始区间的方法称为划界法。 思路：找出三个点$a&lt;c&lt;b$使得函数值满足$f(a)&gt;f(c)&lt;f(b)$即可，否则函数在这一区间单调，继续向函数下降的方向寻找新点。","link":"/2020/08/18/建模-无约束优化问题-1/"},{"title":"建模-因子分析","text":"因子分析因子分析（Factor Analysis，FA）是一种数据简化技术，通过研究众多变量之间的内部依赖关系，探求观测数据的基本结构，并用少数几个假想变量（因子）来表示原始数据。 与主成分分析的区别因子分析区别于主成分分析的地方在于： 因子具有明确解释性，而主成分解释含义较原始数据比较模糊 主成分的解唯一，而因子有多解（由于增加了特殊因子向量），可以进行旋转而增大可解释的可能性 主成分分析不需要构造模型，而因子分析需要构造一个因子模型，并伴随几个关键性的假定 因子分析的一般模型 根据模型意义，我们给出几个重要假设： 性质1. 原始变量X的协方差矩阵分解 说明：特殊因子的协方差越小，公共因子共享的成分越多。 2. 载荷矩阵不唯一 说明：可以通过对载荷矩阵进行正交旋转，在不改变特殊因子的情况下寻求更鲜明的实际意义或可解释性的因子。 载荷矩阵中的统计意义1. 变量共同度 即：横向代表所有载荷因子对某变量影响的程度。 2. 因子重要性 即：纵向代表某载荷因子对整体x变量的贡献度。 3. 因子载荷的统计意义因子载荷$a_{ij}$是第$i$个变量与第$j$个公共因子的相关系数，反映了第$i$个变量与第$ j$个公共因子的相关重要性。绝对值越大，相关的密切程度越高。 载荷矩阵A的估计方法 主成分分析法（这里可以发现是用主成分方法解的） 极大似然估计法 主轴因子法 spss上直接选即可。 载荷矩阵A的旋转方法我们可以通过正交变换使矩阵$A$中有尽可能多的元素等于或接近于0，从而使因子载荷矩阵结构简单化，便于做出更有实际意义的解释。 常用方法有：最大方差法、Oblimin方法、最优斜交旋转等。 spss上直接选即可。 计算公共因子取值——因子得分前面我们主要解决了用公共因子的线性组合来表示一组观测变量的有关问题。如果我们要使用这些因子做其他的研究，比如把得到的因子作为自变量来做回归分析，对样本进行分类或评价，这就需要我们对公共因子进行测度，即给出公共因子的值。 常用Anderson-Rubin方法。 spss上直接选即可。 总结综上所述，因子分析的基本步骤可概括； 求样本相关系数矩阵R的特征值（依大小次序）及其相应的特征向量。 取前面k个特征值使其累积方差贡献率超过85%，并给出前k个特征值对应的特征向量。 求因子载荷矩阵 A 。 对载荷矩阵A作正交旋转 ，使得到的矩阵方差和最大 ref： 因子分析 factor analysis","link":"/2020/08/25/建模-因子分析/"},{"title":"建模-时间序列分析","text":"时间序列分析时间序列是某个数值长期变化的数字表现。 两个要素：时间要素、数值要素。 时期序列可加（例如中国每年的GDP总值） 时点序列不可加（例如某地每隔一小时测得的温度） 时间序列分解长期趋势是指在相当长的一段时间内统计指标持续上升或者下降的趋势。T 季节趋势是指由于季节的转变使得指标数值发生周期性变动。S（百度指数） 循环变动通常以若干年为周期，再曲线图上表现为波浪式的周期变动。C 不规则变动（白噪声）I 四种变动关系：相加/相乘 四种变动相互独立：相加$Y=T+S+C+I$ 四种变动相互影响：乘积$Y=T\\times S\\times C\\times I$ 根据时间序列图，波动越来愈大建议乘积，否则如果保持恒定建议叠加。 SPSS时间序列缺失值处理开头结尾——直接删掉 中间位置——替换缺失值（五种方法） 定义时间变量数据-定义日期与时间-（具体） 时序图分析-时间序列预测-序列图-选择时间轴标签 时间序列分解分析-时间序列预测-季节性分解-加/乘-移动平均值（周期奇数/偶数） 分解后变量 分解后的时序图加上分解后变量重新绘图 时间序列分析具体步骤： 做出序列图 判断变动成分 序列分解（周期&lt;1年） 建立时间序列分析模型 预测未来指标数值","link":"/2020/09/10/建模-时间序列/"},{"title":"建模-无约束优化问题-2","text":"二维搜索方法本文描述了求取实值函数极小点的方法。主要包括最速下降法、牛顿法、拟牛顿法。 梯度下降法又叫最速下降法，是梯度方法的一种具体实现。在目标函数一阶可导时，应利用导数（梯度）的信息， 向负梯度方向搜索前进， 使得每一步的目标函数值都减小。 具体方法是：每次从初始点出发，沿着梯度负方向$-\\nabla f(x^{(k)})$开展一维搜索，找到该方向上的极小值点$x^{(k+1)}$，再从此点继续迭代搜索。 算法优化： 算法的步长选择。步长取值取决于数据样本，可以多取一些值，从大到小，分别运行算法，看看迭代效果，如果损失函数在变小，说明取值有效，否则要增大步长。步长太大，会导致迭代过快，甚至有可能错过最优解。步长太小，迭代速度太慢，很长时间算法都不能结束。所以算法的步长需要多次运行后才能得到一个较为优的值。也可以选择相对值作为停止规则，以避免数据尺度不同造成的影响。例如使用：$$\\frac{|f(x^{(k+1)})-f(x^{(k)})|}{|f(x^{(k)})|}&lt;\\epsilon$$或者$$\\frac{|x^{(k+1)}-x^{(k)}|}{|x^{(k)}|}&lt;\\epsilon$$ 算法参数的初始值选择。初始值不同，获得的最小值也有可能不同，因此梯度下降求得的只是局部最小值；当然如果损失函数是凸函数则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。 归一化。由于样本不同特征的取值范围不一样，可能导致迭代很慢，为了减少特征取值的影响，可以对特征数据归一化。 牛顿法在确定搜索方向时，梯度下降法只是用了一阶导数（梯度），如果函数存在二阶以上导数时，引入高阶导数，则效率可能提高。 原理是利用泰勒公式，在$x_0$处进行二阶泰勒展开。 拟牛顿法 ref： 无约束优化方法 梯度下降法、牛顿法和拟牛顿法","link":"/2020/08/23/建模-无约束优化问题-2/"},{"title":"建模-聚类分析","text":"聚类聚类分析是一种定量方法，从数据的角度，对样本或指标进行分类，进而进行更好的分析。 从分类对象上分为两种： Q型聚类（clustering for individuals 分类样本） R型聚类（clustering for variables 分类变量） ​ Q型是对样本进行分类处理，其作用在于: 1.能利用多个变量对样本进行分类； 2.分类结果直观，聚类谱系图能明确、清楚地表达其数值分类结果； 3.所得结果比传统的定性分类方法更细致、全面、合理。 R型是对变量进行分类处理，其作用在于： 1.可以了解变量间及变量组合间的亲疏关系； 2.可以根据变量的聚类结果及它们之间的关系，选择主要变量进行回归分析或Q型聚类分析。 Q型聚类样本距离(样本的相似性度量)常用的有绝对值距离、欧氏距离。使用欧氏距离必须标准化处理，但避免不了变量的多重相关性。因而多使用马氏距离（ Mahalanobis）：$$d(x,y) = \\sqrt{(x-y)^T\\Sigma^{-1}(x-y)}$$式子中，x、y是来自总体Z两个样本（向量）。∑是Z的协方差矩阵。 此外，还可采用样本相关系数、夹角余弦和其它关联性度量作为相似性度量。 类与类之间的相似性度量 由一个样品组成的类是最基本的类。如果每一类都由一个样品组成，那么样品间的距离就是类间距离。 如果某一类包含不止一个样品，那么就要确定类间距离，类间距离是基于样品间距离定义的。如果有两个样本类G1和G2，我们可以用下面的一系列方法度量它们间的距离： 最短距离法（nearest neighbor or single linkage method）它的直观意义为两个类中最近两点间的距离。 最长距离法（farthest neighbor or complete linkage method） 它的直观意义为两个类中最远两点间的距离。 重心法（centroid method） 类平均法（group average method）它等于G1 ,G2中两两样本点距离的平均，式中n1 , n2 分别为G1 ,G2中的样本点个数。 离差平方和法（sum of squares method）事实上，若 G1 ,G2内部点与点距离很小，则它们能很好地各自聚为一类，并且这两类又能够充分分离（即D12很大），这时必然有D = D12 − D1 − D2 很大。因此，按定义可以认为，两类G1 ,G2之间的距离很大。 Q型聚类步骤： 1 ）计算n个样本点两两之间的距离dij ，记为矩阵D = （dij）（n*n）； 2）首先构造n个类，每一个类中只包含一个样本点，每一类的平台高度均为零 3）合并距离近的两类为新类，并且以这两类间的距离值作为聚类图中的平台高 度； 4）计算新类与当前各类的距离，若类的个数已经等于 1，转入步骤 5），否则，回 到步骤 3）； 5）画聚类图； 6）决定类的个数和类。 Matlab函数 R型聚类R型聚类是更常用的。影响指标有若干，但这些影响因素（自变量）之间可能有相关性，把比较相关的聚成一类，只选用其中的一个因素来代表该类，从而对问题做出简化。 两类之间的距离 r为相关系数。这些操作都是基于相关系数的。 例子：Q型聚类 12345678910111213clc,clear a = [1,0;1,1;3,2;4,3;2,5]; y = pdist(a,'cityblock') %计算绝对值距离yc = squareform(y); z = linkage(y) %最短距离法产生聚类树[h,t] = dendrogram(z) %画聚类图命令T = cluster(z,'maxclust',3) %把对象划分为3类for i = 1:3 tm = find(T == i);%返回第i类对象 tm = reshape(tm,1,length(tm));%编程行向量 fprintf('第%d类对象有%s\\n',i,int2str(tm)); end R型聚类 先提供相关系数矩阵（） 12345678910111213clc,clear a = textread('ch.txt') d = 1 - abs(a); %相关系数转距离d = tril(d); %提出d矩阵的下三角部分b = nonzeros(d);%去掉d的0 b = b'; z = linkage(b,'complete') %最大距离,产生聚类树y = cluster(z,'maxclust',2) %变量分为2类ind1 = find(y == 1); ind1 = ind1' ind2 = find(y == 2); ind2 = ind2' dendrogram(z) %画聚类图","link":"/2020/08/20/建模-聚类分析/"},{"title":"浏览器渲染过程","text":"导航过程完成之后，浏览器进程把数据交给了渲染进程，渲染进程负责tab内的所有事情，核心目的就是将HTML/CSS/JS代码，转化为用户可进行交互的web页面。那么渲染进程是如何工作的？面试中被问到无数次的问题，系统学习下。 渲染进程渲染进程包括： 主线程 多个工作线程 一个合成器线程 多个光栅化线程 构建DOM收到来自网络进程的数据以及浏览器进程的渲染请求后，渲染进程开始解析数据，将其转化为DOM对象。 子资源加载构建DOM的过程中，若解析到CSS/JS/图片等资源，需要从网络/缓存中获取。 为了提升效率，浏览器也会运行预加载扫描程序，如果HTML中存在img、link、script等标签，预加载扫描程序会把这些请求传递给Browser Process的network thread进行资源下载。 JavaScript的下载与执行构建DOM过程中，如果遇到&lt;script&gt;标签，渲染引擎会停止对HTML的解析，而去加载执行JS代码，原因在于JS代码可能会改变DOM的结构（比如执行document.write()等API） 但如果开发者明确知道自己的脚本不会改变dom，那么可以字形添加async或者defer属性，浏览器就会异步加载和执行JS代码，而不阻塞渲染。 defer&amp;async区别没有时： 标记defer时： 标记async时： 通用做法：放到底部 样式计算（CSSOM树构建）DOM树只是页面的结构，而没有节点的样式。浏览器根据层叠和继承规则进行每个节点样式的构建。 继承：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫UserAgent样式。 层叠：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。某种意义上，它处于核心地位，具体的层叠规则属于深入 CSS 语言的范畴。 计算的结果可以从document.styleSheet看到，也就是通常意义上指的CSSOM。 布局上述已经完成DOM以及样式计算，接下来主线程会遍历DOM以及相关元素的样式，计算出包含每个元素页面位置坐标信息以及盒模型大小的布局树（render tree）。遍历过程中会跳过隐藏的元素（display:none），对于不可见的节点，head,meta标签等都会被忽略。。另外，伪元素在布局树上是可见的。 绘制在绘制阶段，主线程会遍历布局树（layout tree），每次都会把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个绘制列表。绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。 合成合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。 通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。 显式合成： 元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。 隐式合成： z-index比较低的节点会提升为一个单独的途图层，那么层叠等级比它高的节点都会成为一个独立的图层。（可能会导致层爆炸） 图层很大时，没有必要一次绘制出全部的图层，因此合成线程将会把图层分块，有了图块之后，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。生成的位图被保存在 GPU 内存中。 当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。 合成帧：代表页面一个帧的内容的绘制四边形集合。 以上所有步骤完成后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。 合成的好处在于这个过程没有涉及到主线程，所以合成线程不需要等待样式的计算以及JavaScript完成执行。这就是为什么合成器相关的动画最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。 PS：回流 重绘 合成回流另外一个叫法是重排，回流触发的条件就是:对 DOM 结构的修改引发 DOM 几何尺寸变化的时候,会发生回流过程。 重绘当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 跳过了布局树和建图层树,直接去绘制列表，然后在去分块,生成位图等一系列操作。 可以看到，重绘不一定导致回流，但回流一定发生了重绘。 合成还有一种情况：就是更改了一个既不要布局也不要绘制的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的合成操作，这个过程就叫合成。 CSS的transform来实现动画效果，避免了回流跟重绘，直接在非主线程中执行合成动画操作。显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。 提升合成层的最好方式是使用 CSS 的 will-change 属性 利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。 参考：前端都该懂的浏览器工作原理，你懂了吗？ 「浏览器工作原理」写给女友的秘籍-渲染流程篇（1.1W字）","link":"/2021/03/17/浏览器渲染过程/"},{"title":"程设Week11-作业","text":"题目突然变多且难度下降？ 1-4过于简单，就偷个懒了 Awhile循环判断到20break即可 B旋转=角对称+水平对称 Ccout&lt;&lt;char(((c-'A')+21)%26+'A') D记相邻两个序列全2/1长度为n/m，合法序列长度就是min（n，m）,然后取个max就是答案 E题目描述一家银行计划安装一台用于提取现金的机器。机器能够按要求的现金量发送适当的账单。机器使用正好N种不同的面额钞票，例如D_k，k = 1,2,…,N，并且对于每种面额D_k，机器都有n_k张钞票。例如，$$N = 3，n_1 = 10，D_1 = 100，n_2 = 4，D_2 = 50，n_3 = 5，D_3 = 10$$表示机器有10张面额为100的钞票、4张面额为50的钞票、5张面额为10的钞票。东东在写一个 ATM 的程序，可根据具体金额请求机器交付现金。注意，这个程序计算程序得出的最大现金少于或等于可以根据设备的可用票据供应有效交付的现金。 输入1程序输入来自标准输入。 输入中的每个数据集代表特定交易，其格式为：Cash N n1 D1 n2 D2 ... nN DN其中0 &lt;= Cash &lt;= 100000是所请求的现金量，0 &lt;= N &lt;= 10是 纸币面额的数量，0 &lt;= nk &lt;= 1000是Dk面额的可用纸币的数量，1 &lt;= Dk &lt;= 1000，k = 1，N。 输入中的数字之间可以自由出现空格。 输入数据正确。 输出对于每组数据，程序将在下一行中将结果打印到单独一行上的标准输出中。 题目分析 多重背包问题，二进制拆分可解 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#define inf 0x3f3f3f3fusing namespace std;int dp[100100];int cash[1000];int cnt;int main(){ int n,ask; while(cin&gt;&gt;ask){ cin&gt;&gt;n; cnt = 0; for(int i = 1;i&lt;=n;i++){ int num,w; cin&gt;&gt;num&gt;&gt;w; int j = num; for(int k=1;j&gt;=k;j-=k,k&lt;&lt;=1){ cash[cnt++] = w*k; } if(j){ cash[cnt++] = w*j; } } for(int i = 1;i &lt;= ask;i++) dp[i] = -inf; for(int i = 0;i &lt; cnt;i++){ for(int v = ask;v &gt;= 0; v--){ if(v-cash[i] &gt;= 0){ dp[v] = max(dp[v],dp[v-cash[i]]+cash[i]); } } } bool flag = 0; for(int i = ask;i &gt;=0 ;i--){ if(dp[i] &gt; 0){ flag = 1; cout&lt;&lt;i&lt;&lt;\"\\n\"; break; } } if(!flag) cout&lt;&lt;\"0\\n\"; } return 0;} F题目描述东东开车出去泡妞(在梦中)，车内提供了 n 张CD唱片，已知东东开车的时间是 n 分钟，他该如何去选择唱片去消磨这无聊的时间呢 假设: CD数量不超过20张 没有一张CD唱片超过 N 分钟 每张唱片只能听一次 唱片的播放长度为整数 N 也是整数 我们需要找到最能消磨时间的唱片数量，并按使用顺序输出答案（必须是听完唱片，不能有唱片没听完却到了下车时间的情况发生） 本题是 Special Judge 输入多组输入 每行输入第一个数字N, 代表总时间，第二个数字 M 代表有 M 张唱片，后面紧跟 M 个数字，代表每张唱片的时长 例如样例一: N=5, M=3, 第一张唱片为 1 分钟, 第二张唱片 3 分钟, 第三张 4 分钟 所有数据均满足以下条件: N≤10000M≤20 输出输出所有唱片的时长和总时长，具体输出格式见样例 题目分析 裸背包，记录答案路径，可用pre数组，借鉴最短路记录路径的方式： pre[v]表示到达v容量时最后使用的哪个物品； 然后可以递推到pre[v-w[pre[v]]]，直到0 spj即可不考虑顺序问题； 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#define inf 0x3f3f3f3fusing namespace std;int dp[100100],pre[100100];int cash[1000];int cnt;int main(){ int n,ask; while(cin&gt;&gt;ask){ cin&gt;&gt;n; cnt = 0; for(int i = 0;i&lt;n;i++){ cin&gt;&gt;cash[i]; } for(int i = 1;i &lt;= ask;i++) dp[i] = -inf; for(int i = 0;i &lt; n;i++){ for(int v = ask;v &gt;= 0; v--){ if(v-cash[i] &gt;= 0){ if(dp[v-cash[i]] + cash[i] &gt; dp[v]){ pre[v] = cash[i]; dp[v] = max(dp[v],dp[v-cash[i]]+cash[i]); } } } } bool flag = 0; for(int i = ask;i &gt;=0 ;i--){ if(dp[i] &gt; 0){ flag = 1; int k = i; while(k){ cout&lt;&lt;pre[k]&lt;&lt;\" \"; k -= pre[k]; } cout&lt;&lt;\"sum:\"&lt;&lt;i&lt;&lt;\"\\n\"; break; } } if(!flag) cout&lt;&lt;\"sum:\"&lt;&lt;\"0\\n\"; } return 0;}","link":"/2020/05/07/程设Week11-作业/"},{"title":"程设Week12-模拟","text":"花式分段，各种分段 A记录一个pre，每当输入一个now，跟pre进行比较，如果不一样则cnt++，pre=now，最后cnt即为答案 B题目描述游戏在一个包含有n行m列的棋盘上进行，棋盘的每个格子都有一种颜色的棋子。当一行或一列 上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地 方的棋子将同时被消除。 一个棋子可能在某一行和某一列同时被消除 输入输入第一行包含两个整数n,m，表示行数和列数 接下来n行m列，每行中数字用空格隔开，每个数字代表这个位置的棋子的颜色。数字都大于0. 输出输出n行m列，每行中数字用空格隔开，输出消除之后的棋盘。（如果一个方格中的棋子被消除， 则对应的方格输出0，否则输出棋子的颜色编号。） 题目分析 我的思路：先按行分段，记录每段的长度，把长度&gt;=3的段打上tag，输出的时候为0；列同理； zyh的思路：直接按行遍历，i-1``i``i+1三个位置相同则打上tag； 我的思路60行，zyh思路30行 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;using namespace std;int mp[40][40];bool tag[40][40];int cnt[40],now;int n,m;int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i = 0;i&lt; n;i++){ for(int j = 0;j&lt; m;j++){ cin&gt;&gt;mp[i][j]; } } for(int i = 0;i&lt;n;i++){ int pre = mp[i][0]; now = 0; cnt[0] = 1; for(int j = 1;j&lt;m;j++){ if(pre != mp[i][j] ){ cnt[++now] = 1; pre = mp[i][j]; }else cnt[now]++; } int sum = 0; for(int j = 0;j&lt;=now;j++){ if(cnt[j] &gt;= 3){ for(int z = 0;z &lt; cnt[j];z++){ tag[i][sum+z] = 1; } } sum += cnt[j]; } } for(int i = 0;i&lt; m;i++){ int pre = mp[0][i]; now = 0; cnt[0] = 1; for(int j = 1;j&lt;n;j++){ if(pre != mp[j][i] ){ cnt[++now] = 1; pre = mp[j][i]; }else cnt[now]++; } int sum = 0; for(int j = 0;j&lt;=now;j++){ if(cnt[j] &gt;= 3){ for(int z = 0;z &lt; cnt[j];z++){ tag[sum+z][i] = 1; } } sum += cnt[j]; } } for(int i = 0;i&lt;n;i++){ if(tag[i][0]) cout&lt;&lt;0; else cout&lt;&lt;mp[i][0]; for(int j = 1;j&lt;m;j++){ if(tag[i][j]) cout&lt;&lt;\" \"&lt;&lt;0; else cout&lt;&lt;\" \"&lt;&lt;mp[i][j]; } cout&lt;&lt;\"\\n\"; } return 0;} C题目描述给定一个串，求有多少子串是delicious的 Delicious定义：对于一个字符串，我们认为它是Delicious的当且仅当它的每一个字符都属于一个 大于1的回文子串中。 输入输入第一行一个正整数n，表示字符串长度。接下来一行，一个长度为n只由大写字母A、B构成的字符串。 输出输出仅一行，表示符合题目要求的子串的个数。 数据范围n&lt;=3e5 题目分析 首先来说，单个字符的子串是不合法的； 也就是说，合法子串的长度length&gt;=2；总共由n(n-1)/2个这样的子串 突破口很明显在“只由AB构成的字符串” 我们考虑不合法的串 AA合法，BB合法 AAB不合法，BAA不合法 会发现只要存在*A/B*形式，必然合法 会发现只有AB* 和*AB形式的子串是不合法的； 那么所有的这些不合法子串的长度为n*2-头尾段的长度 想到这，不禁直呼巧妙！！ 代码123456789101112131415161718#include&lt;iostream&gt;using namespace std;long long sum[500000],cnt,n;int main(){ cin&gt;&gt;n; string s; cin&gt;&gt;s; long long ans = n*(n-1)/2; char pre = s[0]; for(int i = 0;i&lt;n;i++){ if(pre != s[i]){ pre = s[i]; sum[++cnt] = 1; }else sum[cnt]++; } cout&lt;&lt;ans-n*2+cnt+sum[0]+sum[cnt]; return 0;}","link":"/2020/05/07/程设Week12-模拟/"},{"title":"程设Week14-模拟","text":"又是时间模拟—、— 题目描述众所周知，TT家里有一只魔法喵。这只喵十分嗜睡。一睡就没有白天黑夜。喵喵一天可以睡多次！！每次想睡多久就睡多久╭(╯^╰)╮ 喵睡觉的时段是连续的，即一旦喵喵开始睡觉了，就不能被打扰，不然喵会咬人哒[○･｀Д´･ ○] 可以假设喵喵必须要睡眠连续不少于 A 个小时，即一旦喵喵开始睡觉了，至少连续 A 个小时内（即A*60分钟内）不能被打扰！ 现在你知道喵喵很嗜睡了，它一天的时长都在吃、喝、拉、撒、睡，换句话说要么睡要么醒着滴！ 众所周知，这只魔法喵很懒，和TT一样懒，它不能连续活动超过 B 个小时。 猫主子是不用工作不用写代码滴，十分舒适，所以，它是想睡就睡滴。 但是，现在猫主子有一件感兴趣的事，就是上BiliBili网站看的新番。 新番的播放时间它已经贴在床头啦（每天都用同一张时间表哦），这段时间它必须醒着！！ 作为一只喵喵，它认为安排时间是很麻烦的事情，现在请你帮它安排睡觉的时间段。 输入多组数据，多组数据，多组数据哦，每组数据的格式如下： 第1行输入三个整数，A 和 B 和 N (1 &lt;= A &lt;= 24, 1 &lt;= B &lt;= 24, 1 &lt;= n &lt;= 20) 第2到N+1行为每日的新番时间表，每行一个时间段，格式形如 hh:mm-hh:mm (闭区间)，这是一种时间格式，hh:mm 的范围为 00:00 到 23:59。注意一下，时间段是保证不重叠的，但是可能出现跨夜的新番，即新番的开始时间点大于结束时间点。保证每个时间段的开始时间点和结束时间点不一样，即不可能出现类似 08:00-08:00 这种的时间段。时长的计算由于是闭区间所以也是有点坑的，比如 12:00-13:59 的时长就是 120 分钟。不保证输入的新番时间表有序。 输出我们知道，时间管理是一项很难的活，所以你可能没有办法安排的那么好，使得这个时间段满足喵喵的要求，即每次睡必须时间连续且不少于 A 小时，每次醒必须时间连续且不大于 B 小时，还要能看完所有的番，所以输出的第一行是 Yes 或者 No，代表是否存在满足猫猫要求的时间管理办法。 然后，对于时间管理，你只要告诉喵喵，它什么时候睡觉即可。即第2行输出一个整数 k，代表当天有多少个时间段要睡觉接下来 k 行是喵喵的睡觉时间段，每行一个时间段，格式形如 hh:mm-hh:mm (闭区间)，这个在前面也有定义。注意一下，如果喵喵的睡眠时段跨越当天到达了明天，比如从23点50分睡到0点40分，那就输出23:50-00:40，如果从今晚23:50睡到明天早上7:30，那就输出23:50-07:30。 输出要排序吗？（输出打乱是能过的，也就是说，题目对输出的那些时间段间的顺序是没有要求的） 哦对了，喵喵告诉你说，本题是 Special Judge，如果你的输出答案和 Sample 不太一样，也可能是对的，它有一个判题程序来判定你的答案（当然，你对你自己的答案肯定也能肉眼判断） 题目分析 原则：能睡就睡，否则不睡。 跨天的处理：直接在第二天的时间上加上24h 最后一个事件的结束时间与第一个事件的开始时间中间事件段的处理：把第一个事件作为n+1个事件加24h然后加到序列末尾。 坑点： 不能24h不睡，因为和第二天连起来就是48h不睡，和第三天连起来就是。。永远不睡，必然是不存在的。 睡觉区间是闭区间，因此要注意+1-1 小tips： printf(&quot;%02d:%02d-%02d:%02d\\n&quot;,...)用于控制输出，香！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct event{ int begin,end; int t; event(int b,int e):begin(b),end(e){} event(){begin = end = t = 0;}}avi[50],slp[50];bool cmp(event&amp; a,event&amp; b){ return a.begin &lt; b.begin;}int scnt;int main(){ int A,B,k; while(~scanf(\"%d%d%d\",&amp;A,&amp;B,&amp;k)){ scnt = 0; A *= 60,B *= 60; memset(slp,0,sizeof(slp)); memset(avi,0,sizeof(avi)); int sh,sm,eh,em; bool flag = true; for(int i = 0;i&lt;k;i++){ scanf(\"%d:%d-%d:%d\",&amp;sh,&amp;sm,&amp;eh,&amp;em); avi[i] = event(sh*60+sm,eh*60+em); if(avi[i].end &lt; avi[i].begin) avi[i].end += 24*60; } sort(avi,avi+k,cmp); avi[k] = event(avi[0].begin + 24 * 60 , avi[0].end + 24 * 60); for(int i = 1;i&lt;=k;i++){ if(avi[i].begin -1 - avi[i-1].end &gt;= A ){ slp[scnt++] = event(avi[i-1].end + 1,avi[i].begin - 1); } } slp[scnt] = event(slp[0].begin + 24 * 60,slp[0].end + 24 * 60); for(int i = 1; i&lt;=scnt;i++){ if(slp[i].begin - 1 - slp[i-1].end &gt; B) {flag = false;break;} } if(!flag || scnt == 0 ) { cout&lt;&lt;\"No\\n\"; continue; }else { cout&lt;&lt;\"Yes\\n\"&lt;&lt;scnt&lt;&lt;\"\\n\"; for(int i = 0;i&lt;scnt;i++){ slp[i].begin += 24*60; slp[i].begin %= 24*60 ; slp[i].end += 24*60; slp[i].end %= 24*60; printf(\"%02d:%02d-%02d:%02d\\n\",slp[i].begin / 60,slp[i].begin % 60,slp[i].end / 60 ,slp[i].end % 60); } } }}","link":"/2020/06/10/程设Week14-模拟/"},{"title":"程设Week13-15-作业","text":"dpdpdpdp TT 的神秘任务3题目描述TT 猫咖的生意越来越红火，人越来越多，也越来越拥挤。 为了解决这个问题，TT 决定扩大营业规模，但猫从哪里来呢？ TT 第一时间想到了神秘人，想要再次通过完成任务的方式获得猫咪。 而这一次，神秘人决定加大难度。 给定一个环，A[1], A[2], A[3], … , A[n]，其中 A[1] 的左边是 A[n]。要求从环上找出一段长度不超过 K 的连续序列，使其和最大。 这一次，TT 陷入了沉思，他需要你们的帮助。 输入第一行一个整数 T，表示数据组数，不超过 100。 每组数据第一行给定两个整数 N K。（1 ≤ N ≤ 100000, 1 ≤ K ≤ N） 接下来一行，给出 N 个整数。（-1000 ≤ A[i] ≤ 1000）。 输出对于每一组数据，输出满足条件的最大连续和以及起始位置和终止位置。 如果有多个结果，输出起始位置最小的，如果还是有多组结果，输出长度最短的。 题目分析 环上——复制数组接到原数组后面 连续序列——考虑前缀和、单调队列 首先处理出原序列的前缀和数组，然后利用单调队列滑动窗口的思想，维护一个单调升的队列（因为每次要找到前面前缀和最小的位置，才能保证得到的连续序列和最大） 注意：先pop，再更新答案，最后将新元素加入队列末尾。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define ll long long#define inf 0x3f3f3f3fint a[2001000];// int dp[200100];inline int read(){ int out = 0,flag = 1;char c = getchar(); while (c &lt; 48 || c &gt; 57) {if (c == '-') flag = -1; c = getchar();} while (c &gt;= 48 &amp;&amp; c &lt;= 57) {out = out * 10 + c - 48; c = getchar();} return out * flag;}int sum[2001000];int main(){ int T; cin&gt;&gt;T; while(T--){ memset(sum,0,sizeof(sum)); // memset(dp,0,sizeof(dp)); int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i =1;i&lt;=n;i++){ a[i+n] = a[i] = read(); sum[i] = a[i] + sum[i-1]; } for(int i = n+1;i&lt;=n*2;i++){ sum[i] = a[i] + sum[i-1]; } deque&lt;int&gt; q; int ans = -inf ,l = 1,r = 1; q.push_back(0); for(int i = 1;i&lt;=n*2;i++){ if(q.size() &amp;&amp; q.front() &lt; i-k) q.pop_front(); if(ans &lt; sum[i] - sum[q.front()] ){ ans = sum[i] - sum[q.front()]; l = q.front()+1; r = i&gt;n ? i-n:i; } while(q.size() &amp;&amp; sum[q.back()] &gt; sum[i]) q.pop_back(); q.push_back(i); } printf(\"%d %d %d\\n\",ans,l,r); }} E - Q老师度假题目描述忙碌了一个学期的 Q老师 决定奖励自己 N 天假期。 假期中不同的穿衣方式会有不同的快乐值。 已知 Q老师 一共有 M 件衬衫，且如果昨天穿的是衬衫 A，今天穿的是衬衫 B，则 Q老师 今天可以获得 f[A][B] 快乐值。 在 N 天假期结束后，Q老师 最多可以获得多少快乐值？ 输入输入文件包含多组测试样例，每组测试样例格式描述如下： 第一行给出两个整数 N M，分别代表假期长度与 Q老师 的衬衫总数。（2 ≤ N ≤ 100000, 1 ≤ M ≤ 100） 接下来 M 行，每行给出 M 个整数，其中第 i 行的第 j 个整数，表示 f[i][j]。（1 ≤ f[i][j] ≤ 1000000） 测试样例组数不会超过 10。 输出每组测试样例输出一行，表示 Q老师 可以获得的最大快乐值。 题目分析 分析题目可以得出，转移方程可以写为：dp[i][B] = max(dp[i-1][k]+f[k][B]) $$ans[i] = \\begin{bmatrix}dp[i][1] \\\\vdots \\dp[i][m]\\end{bmatrix}=\\begin{bmatrix}f[1][1] &amp; \\cdots &amp; f[m][1] \\\\vdots &amp; \\ddots &amp; \\vdots \\f[1][m] &amp; \\cdots &amp; f[m][m]\\end{bmatrix}\\oplus\\begin{bmatrix}f[i-1][1] \\\\vdots\\f[i-1][m]\\end{bmatrix}$$ $\\oplus $运算将矩阵乘法的累加换成了max，乘换成了加（符合结合律、交换律） 那么只要构造出中间矩阵，做快速幂即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;struct matrix{ long long mtx[105][105]; int m,n; matrix(int n,int m):n(n),m(m){ for(int i = 1;i&lt;=n;i++) for(int j = 1;j&lt;=m;j++) mtx[i][j] = 0; } matrix operator * (const matrix&amp; x){ matrix ans(n,x.m); if(m != x.n) return ans; for(int i = 1;i &lt;= n;i++){ for(int j = 1;j&lt;=x.m;j++){ for(int k = 1;k&lt;= m;k++){ ans.mtx[i][j] = max(ans.mtx[i][j],mtx[i][k]+x.mtx[k][j]); } } } return ans; } // matrix (const matrix &amp;t){ // memcpy(mtx,t.mtx,sizeof(mtx)); // } void show(){ cout&lt;&lt;\"\\n\"; for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=m;j++){ cout&lt;&lt;mtx[i][j]&lt;&lt;\" \"; }cout&lt;&lt;\"\\n\"; } }};matrix fast_pow(matrix x,int p){ matrix a(x.n,x.m); for(;p;p&gt;&gt;= 1,x = x * x){ if(p&amp;1){ a = a * x; } } return a;}int main(){ int n,m; while(cin&gt;&gt;n&gt;&gt;m){ matrix a(m,m); matrix ori(m,1); for(int i = 1;i&lt;=m;i++){ ori.mtx[i][1] = 0; for(int j = 1;j&lt;=m;j++){ cin&gt;&gt;a.mtx[i][j]; } } matrix ans = fast_pow(a,n-1) * ori; long long anss = 0; for(int i = 1;i&lt;=m;i++){ anss = max(anss,ans.mtx[i][1]); } cout&lt;&lt;anss&lt;&lt;\"\\n\"; }} B - ZJM 与生日礼物题目描述ZJM 收到了 Q老师 送来的生日礼物，但是被 Q老师 加密了。只有 ZJM 能够回答对 Q老师 的问题，Q老师 才会把密码告诉 ZJM。 Q老师 给了 ZJM 一些仅有 01 组成的二进制编码串, 他问 ZJM：是否存在一个串是另一个串的前缀. 输入多组数据。每组数据中包含多个仅有01组成的字符串，以一个9作为该组数据结束的标志。 输出对于第 k 组数据(从1开始标号)，如果不存在一个字符串使另一个的前缀，输出”Set k is immediately decodable”，否则输出”Set k is not immediately decodable”。每组数据的输出单独一行 题目分析 直接插入构造字典（？二叉）树 把一个字符串每一位放到字典树上，每次新拓展一个节点时++cnt，否则直接移动到已经存在的节点上，过程中如果遇到flag，或者最终移动到已经存在的节点上则直接返回存在前缀，否则返回不存在。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;struct rec{ int c[2]; int flag;}node[200000];int cnt;bool insert(string s){ int now = 0; bool res = 0; for(int i = 0;i &lt; s.size();i++){ if(node[now].c[s[i]-'0'] == 0){ node[now].c[s[i]-'0'] = ++cnt; now = cnt; }else now = node[now].c[s[i]-'0']; if(node[now].flag == 1) {return true;} } node[now].flag = 1; if(now == cnt) return false; else return true;}int main(){ string s; bool f = 0; int k = 1; while(cin&gt;&gt;s){ if(s[0] == '9'){ if(!f) cout&lt;&lt;\"Set \"&lt;&lt;k&lt;&lt;\" is immediately decodable\\n\"; else cout&lt;&lt;\"Set \"&lt;&lt;k&lt;&lt;\" is not immediately decodable\\n\"; f = 0; memset(node,0,sizeof(node)); cnt = 0; k++; }else { f = insert(s) || f; } }}","link":"/2020/06/13/程设Week13-15-作业/"},{"title":"程设Week2 作业","text":"本周bfs专题训练 T1 Maze题目描述​ 东东有一张地图，想通过地图找到妹纸。地图显示，0表示可以走，1表示不可以走，左上角是入口，右下角是妹纸，这两个位置保证为0。既然已经知道了地图，那么东东找到妹纸就不难了，请你编一个程序，写出东东找到妹纸的最短路线。 题目分析 起点终点已经确定，地图大小也已经确定，因此无需考虑数据，直接从起点bfs即可。 由于要求输出路径而不是步数，因此每次转移时需要记录上一个状态，在到达终点后直接倒序输出就可以了。 可以用指针或者数组模拟指针来记录历史状态。 一个位置能不能走到的前提有两个：1. 没有墙 2. 之前没有走过。 四个方向行走可以用经典的方法：开两个数组，分别代表向四个方向移动的坐标变化。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int map[10][10];bool v[10][10];struct cord{ int x,y; cord* from; //用来记录之前的状态 cord(int x,int y,cord* from = NULL):x(x),y(y),from(from){}};int zx[4] = {0,0,1,-1};int zy[4] = {1,-1,0,0};inline void output(cord* last){ if(last-&gt;from == NULL){ cout&lt;&lt;\"(0, 0)\\n\"; return; }else{ output(last-&gt;from); cout&lt;&lt;\"(\"&lt;&lt;last-&gt;x-1&lt;&lt;\", \"&lt;&lt;last-&gt;y-1&lt;&lt;\")\\n\"; }}void bfs(){ queue&lt;cord*&gt; q; q.push(new cord(1,1)); v[1][1] = 1; while(!q.empty()){ cord* now = q.front(); q.pop(); for(int i=0;i&lt;4;i++){ int tx = now-&gt;x + zx[i]; int ty = now-&gt;y + zy[i]; if(tx &lt; 6 &amp;&amp; tx &gt;0 &amp;&amp; ty &lt; 6 &amp;&amp; ty &gt; 0 &amp;&amp; map[tx][ty] == 0&amp;&amp; !v[tx][ty]){ if(tx == 5&amp;&amp;ty == 5){ output(new cord(tx,ty,now)); return; } else { v[tx][ty] = 1; q.push(new cord(tx,ty,now)); } } } }}int main(){ for(int i = 1;i&lt;=5;i++){ for(int j = 1;j&lt;=5;j++){ cin&gt;&gt;map[i][j]; } } bfs(); return 0;} T2 Pour Water题目描述经典的倒水问题，有两个容量分别为A，B升的杯子，每个杯子支持三种操作： 把杯子倒满 把杯子倒空 把这个杯子里的水倒到另一个杯子 问能不能倒出C升的水 保证A，B互质。 输出操作次数最少的操作流程（不唯一）。 题目分析 xxx最少balabalabala，用bfs比较多（当然本期主题是bfs 康复训练 练习） 一个杯子支持三个操作，那么两个杯子支持六种操作。也就是对于某个时刻的两个杯子，下一个时刻可能存在的状态有六种，其实也就是bfs时最多产生六个分支。 用面向对象思想，给每个bottle写三个方法：$ pourIn(),pourOut(),pourTo(bottle&amp;) $ 分别代表三种操作。这样写出来的代码比较清晰明了。（虽然看上去很长2333） 输出操作流程。和上一题同样的思想，用指针记录上一个状态，最后倒序输出。不太一样的是还要多记录一个opt：从上一个状态到当前状态的操作（倒满/倒空/倒到另一个杯子） 同时也要开一个数组记录当前状态是否达到过，如果到过就不用重复入队了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118struct bottle{ int capicity; int water; // 三种操作 void pourTo(bottle&amp; b){ b.water = b.water+this-&gt;water; if(b.water &gt; b.capicity){ this-&gt;water = b.water - b.capicity; b.water = b.capicity; }else{ this-&gt;water = 0; } } void pourOut(){ this-&gt;water = 0; } void pourIn(){ this-&gt;water = this-&gt;capicity; } bottle(int x):capicity(x){ water = 0; }};struct sta{ // 再抽象出一个状态，该状态包括某个时刻的两个杯子 bottle A,B; sta* last; int opt; sta(bottle A,bottle B,sta* last):A(A),B(B),last(last){}};void output(sta* his){ if(his!=NULL){ output(his-&gt;last); switch (his-&gt;opt) { case 1: cout&lt;&lt;\"fill A\\n\"; break; case 2: cout&lt;&lt;\"empty A\\n\"; break; case 3: cout&lt;&lt;\"pour A B\\n\"; break; case 4: cout&lt;&lt;\"fill B\\n\"; break; case 5: cout&lt;&lt;\"empty B\\n\"; break; case 6: cout&lt;&lt;\"pour B A\\n\"; break; default: break; } }else{ return; }}int v[1010][1010];void bfs(int a,int b,int c){ memset(v,0,sizeof(v)); sta* status = new sta(bottle(a),bottle(b),NULL); queue&lt;sta*&gt; q; v[0][0] = 1; q.push(status); while(!q.empty()){ sta* head = q.front(); for(int i = 1;i&lt;=6;i++){ sta* f = new sta(*head); switch(i){ case 1:{ f-&gt;A.pourIn(); break; } case 2:{ f-&gt;A.pourOut(); break; } case 3:{ f-&gt;A.pourTo(f-&gt;B); break; } case 4:{ f-&gt;B.pourIn(); break; } case 5:{ f-&gt;B.pourOut(); break; } case 6:{ f-&gt;B.pourTo(f-&gt;A); break; } } if(!v[f-&gt;A.water][f-&gt;B.water]){ v[f-&gt;A.water][f-&gt;B.water] = 1; f-&gt;last = head; f-&gt;opt = i; if(f-&gt;A.water == c || f-&gt;B.water == c){ output(f); cout&lt;&lt;\"success\\n\"; return; }else q.push(f); } } q.pop(); }}int main(){ int a,b,c; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c){ bfs(a,b,c); } return 0;} 反思可以用函数数组来改写一下： 12345void (*p[6])(bottle&amp; a,bottle&amp; b) //定义for(int i = 0;i &lt; 6;i++){ p[i](a,b); //使用} 不过这就得定义六个函数，代码量不一定能减少多少，只是提供一种思路。","link":"/2020/03/01/程设Week2-作业/"},{"title":"程设Week3 作业","text":"本周剪枝、贪心专题训练 T1 选数问题题目描述给出n个数，从中选出和为S的K个数，问有几种方案？ 输入第一行T表示数据组数；第二行n，K，S；第三行n个数； $k&lt;=n&lt;=16$ 输出对于每组输入，输出对应的方案数。 题目分析(看数据的话直接暴力好像也能过的样子？) 剪枝专题当然得用剪枝。 可行性剪枝：如果当前状态还需要选k个，和为s，那么满足下列条件之一时： $k\\times Max \\le s$ 取k个剩下数的最大值都达不到s $k\\times Min \\ge s$ 取k个剩下数的最小值都会比s大 就可以被剪掉 小trick：如果动态求剩下的数的最小最大值的话，虽然最多只有16个数，但是复杂度也是O(n^2)级别，而且还得单独写函数。不如一开始就把这些数排下序，然后从左到右递归选或不选就好。这样Min就是当前的数，Max就可以取最后的数。 代码12345678910111213141516171819202122232425262728int num[100],n,ans;void dfs(int k,int s,int pos){ if(s == 0 &amp;&amp; k == 0){ ans++; return; } if(s &gt; k*num[n-1] || s &lt; k*num[pos]){ return; } dfs(k-1,s-num[pos],pos+1); dfs(k,s,pos+1);}int main(){ int T; cin&gt;&gt;T; while(T--){ int k,s; ans = 0; cin&gt;&gt;n&gt;&gt;k&gt;&gt;s; for(int i = 0;i &lt; n;i++){ cin&gt;&gt;num[i]; } sort(num,num+n); dfs(k,s,0); cout&lt;&lt;ans&lt;&lt;\"\\n\"; } return 0;} T2 区间选点题目描述数轴上有 n 个闭区间 $[a_i, b_i]$。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个） 输入第一行1个整数N（N&lt;=100）第2~N+1行，每行两个整数a,b（a,b&lt;=100） 输出一个整数，代表选点的数目 题目分析 如果每个线段独立，那么最终结果显然是n；如果存在两个线段重合，那么结果是n-1； 先把每个线段按照右端点从小到大排序。（左端点排序也能做，稍微麻烦一点） 然后从第一个线段开始，每次把后边线段左端点在自己右端点左边的情况找出来，并且令答案-1； 单纯的上述处理结果是错误的，因为考虑到下面这种情况： 结果应该是2，但是上述算法得出1.因为A在之前的B、C的遍历过程中被遍历到了2次。 那我们每次找到符合上述要求的线段之后，还要给他打上（已遍历）的标记，避免后续重复遍历。 代码123456789101112131415161718192021222324252627282930struct rec{ int a,b;}p[200];bool vis[200];bool cmp(const rec&amp; a,const rec&amp; b){ return a.b &lt; b.b;}int main(){ int n ; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;p[i].a&gt;&gt;p[i].b; } sort(p+1,p+1+n,cmp); int ans = n; int i = 1; while(i&lt;=n){ if(!vis[i]){ for(int j = i+1;j &lt;= n;j++){ if(!vis[j] &amp;&amp; p[j].a&lt;= p[i].b){ ans--; vis[j] = 1; } } } i++; } cout&lt;&lt;ans; return 0;} T3 区间覆盖题目描述数轴上有 $n (1\\le n\\le 25000)$个闭区间 $[ai, bi]$，选择尽量少的区间覆盖一条指定线段 $[1, t]$, 其中$1\\le t\\le 1,000,000$覆盖整点，即$(1,2)+(3,4)$可以覆盖$(1,4)$不可能办到输出-1 输入多组样例输入 每组样例第一行为$n,t$ 然后输入n个区间 输出每次输出单独的一行，选择区间的数目，不能覆盖则输出-1 题目分析 贪心每次选取能向右拓展最长的线段即可。 先按照左端点排序（这次右端点排序不能做了），然后从第一个线段开始，找到后边所有线段中左端点在自己右端点左边的线段，从中取右端点离自己右端点最远的，将其作为下一个线段重复上述操作。 因为是按照左端点排序，因此在后续的线段中只要找到左端点&gt;自身右端点的线段就可以停止，进入下一个线段继续找了。 无法覆盖的情况： 所有线段中没有左端点&lt;=1 所有线段中没有右端点&gt;=t（找到最后右端点不能再拓展时还是够不到 t ） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct rec{ int a,b;}p[25001];bool cmp(const rec&amp; a,const rec&amp; b){ return a.a &lt; b.a;}int main(){ int n,t; while(cin&gt;&gt;n&gt;&gt;t){ int ans = 1; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;p[i].a&gt;&gt;p[i].b; } sort(p+1,p+1+n,cmp); int sel = 0; for(int i = 1;i&lt;=n;i++){ if(p[i].a == 1) { sel = i; break; } } if(sel == 0) { cout&lt;&lt;\"-1\\n\"; }else{ int pos = p[sel].b; while(pos &lt; t ){ int initsel = sel; int nex = pos; for(int i = sel + 1;i &lt;= n;i++){ if(p[i].a &lt;= pos + 1) { if(p[i].b &gt; nex){ nex = p[i].b; sel = i; } }else break; } pos = nex; if(sel == initsel) break; ans++; } if(pos &gt;= t) cout&lt;&lt;ans&lt;&lt;\"\\n\"; else cout&lt;&lt;\"-1\\n\"; } } return 0;} 反思 遇到线段这样的题拿手画画写写效率会高得多（雾 T1果然直接暴力就能A啊。。","link":"/2020/03/07/程设Week3-作业/"},{"title":"程设Week4-作业","text":"程设Week4-作业本周贪心、二分专场 A - DDL 的恐惧题目描述ZJM 有 n 个作业，每个作业都有自己的 DDL，如果 ZJM 没有在 DDL 前做完这个作业，那么老师会扣掉这个作业的全部平时分。 所以 ZJM 想知道如何安排做作业的顺序，才能尽可能少扣一点分。 请你帮帮他吧！ 输入输入包含T个测试用例。输入的第一行是单个整数T，为测试用例的数量。 每个测试用例以一个正整数N开头(1&lt;=N&lt;=1000)，表示作业的数量。 然后两行。第一行包含N个整数，表示DDL，下一行包含N个整数，表示扣的分。 输出对于每个测试用例，您应该输出最小的总降低分数，每个测试用例一行。 题目分析 倒序枚举天数，每到某天就把ddl为那一天的任务全都加到大根堆里，如此保证大根堆里的任务ddl&gt;=当前天 在上述条件下，采取贪心策略：能选价值大的必然不会选价值小的，毕竟大家都还没到ddl。 正确性：假设某天选择了价值次大的，必然不会是ddl&gt;最大价值的任务的（否则，考虑a任务的价值高且ddl近，b任务的价值小且ddl远，先做哪一个？）。但是根据我们的策略，此时这个任务应该还没被压到堆中，因此必然会选择最大的。 需要注意的是，任务个数$\\neq$天数 代码123456789101112131415161718192021222324252627282930313233343536373839404142struct rec{ int ddl,sc;}task[10010];priority_queue&lt;int&gt; q; bool cmp(const rec &amp;a,const rec &amp;b){ return a.ddl &gt; b.ddl;}int main(){ int T; cin&gt;&gt;T; while(T--){ int n; cin&gt;&gt;n; int maxs = 0; for(int i = 0;i &lt; n;i++){ cin&gt;&gt;task[i].ddl; maxs = max(task[i].ddl,maxs); } int tot = 0; while(!q.empty()) q.pop(); for(int i = 0;i &lt; n;i++){ cin&gt;&gt;task[i].sc; tot += task[i].sc; } sort(task,task+n,cmp); int cnt = 0; for(int i = maxs;i&gt;=1;i--){ while(cnt &lt; n &amp;&amp; task[cnt].ddl == i){ q.push(task[cnt++].sc); } if(!q.empty()){ tot -= q.top(); q.pop(); } } cout&lt;&lt;tot&lt;&lt;\"\\n\"; } return 0;} B - 四个数列题目描述ZJM 有四个数列 A,B,C,D，每个数列都有 n 个数字。ZJM 从每个数列中各取出一个数，他想知道有多少种方案使得 4 个数的和为 0。 当一个数列中有多个相同的数字的时候，把它们当做不同的数对待。 输入第一行：n（代表数列中数字的个数） （1≤n≤4000） 接下来的 n 行中，第 i 行有四个数字，分别表示数列 A,B,C,D 中的第 i 个数字（数字不超过 2 的 28 次方） 输出输出不同组合的个数。 问题分析 暴力枚举过不了，考虑拆成$2\\times n^2$的复杂度 枚举集合$X = A_i+ B_j$，那么对于X中的每个数，在集合$Y = C_i + D_j$中找到其相反数即可 复杂度排序$O(2n^2logn)$，二分查找$O(2n^2 logn)$ 对应的相反数可能有很多，需要找到上界和下界，才能算出对应的区间大小 代码123456789101112131415161718192021222324252627int a[4010],b[4010],c[4010],d[4010];vector&lt;int&gt; s;int main(){ int n; cin&gt;&gt;n; for(int i = 0;i&lt;n;i++){ cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i]&gt;&gt;d[i]; } for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;n;j++){ s.push_back(a[i]+b[j]); } } sort(s.begin(),s.end()); int ans = 0; for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;n;j++){ int k = c[i]+d[j]; vector&lt;int&gt;::iterator low = lower_bound(s.begin(),s.end(),-k); vector&lt;int&gt;::iterator up = upper_bound(s.begin(),s.end(),-k); ans += (up-low); } } cout&lt;&lt;ans&lt;&lt;\"\\n\"; return 0;} // namespace std; C - TT 的神秘礼物题目描述给定一个 N 个数的数组 cat[i]，并用这个数组生成一个新数组 ans[i]。新数组定义为对于任意的 i, j 且 i != j，均有 ans[] = abs(cat[i] - cat[j])，1 &lt;= i &lt; j &lt;= N。试求出这个新数组的中位数，中位数即为排序之后 (len+1)/2 位置对应的数字，’/‘ 为下取整。 输入多组输入，每次输入一个 N，表示有 N 个数，之后输入一个长度为 N 的序列 cat， cat[i] &lt;= 1e9 , 3 &lt;= n &lt;= 1e5 输出输出新数组 ans 的中位数 问题分析 先给数组排个序，就可以把绝对值去掉。ans数组总长度为$\\frac{n\\times(n-1)}{2}$ 假设中位数为p，那么满足$cat_j-cat_i &lt; p$，$j&gt;i$ 的数对$(i,j)$占新数组总数的一半以下，变换一下即$cat_i&lt;cat_j+p$ 那么我们通过枚举i再二分就可在$O(nlogn)$复杂度下算出新数组中小于p的数的个数num。 如果$num&gt;(len(ans)+1)/2$，那么说明p比实际中位数大，应该取小一些；否则说明p比实际中位数小。会发现p也满足二分性质。 那么我们只要再二分p即可。复杂度$(nlog^2n)$ 注意时间卡的比较死，用scanf或快读 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int n,cat[300010];int check(int k){ int tot = 0; for(int i = 1;i&lt;n;i++){ int l=i+1,r=n; int ans = n; while(l&lt;=r){ int mid = (l+r)&gt;&gt;1; if(cat[mid] &gt;= k+cat[i]){ r = mid - 1; }else { l = mid + 1; } } if(r&gt;i) tot += r-i; } return tot;}int read(){ int c= getchar(); while(!isdigit(c)){ c = getchar(); } int ans = 0; while(isdigit(c)){ ans = ans * 10 + (c-'0'); c = getchar(); } return ans;}int main(){ while(~scanf(\"%d\",&amp;n)){ for(int i = 1;i&lt;=n;i++){ cat[i] = read(); } sort(cat+1,cat+n+1); int l=0,r=1e9+10; int num = (n*(n-1)/2+1)/2; while(l&lt;=r){ int mid = (l+r)&gt;&gt;1; if(check(mid)&gt;=num){ r = mid - 1; }else { l = mid + 1; } } cout&lt;&lt;r&lt;&lt;\"\\n\"; } return 0;} 二分特点 使用 l&lt;=r / mid = (l+r)&gt;&gt;1 / r = mid - 1 &amp; l = mid + 1的前提下， 答案分布： R | L ———- 答案区间 ————- R | L","link":"/2020/03/20/程设Week4-作业/"},{"title":"网络流24题|最小路径覆盖问题","text":"时隔多年的by终于想起来更新博客了 算是疫情推动吧 争取每日/隔日更新一篇不拖更 今天的题 思路：最小路径覆盖的定义 考虑最简单的图：如果图中没有边，那么每个点都相当于一条独立路径；添加一条边，那么最小路径条数就-1；此时再添加一条边，会产生两种情况： 新边与上一条边有相同的起点或终点，此时对答案没有贡献； 新边与上一条边首尾相连，或不相交，此时最小路径条数-1； 那么问题转化为：从一个有向无环图中选出尽可能多的边，使得任意两条边没有相同的起点或终点 也就是： |G|- 最大匹配 = 最小路径覆盖 从而可以通过拆点+二分图匹配解决 至于二分图算法，使用dinic在拆点图上跑最大流即可 复杂度O(mn^2) 当然匈牙利算法也可 时间复杂度O(mn) 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150;struct Node;struct Edge;struct Node{ Edge *firstEdge; int id,level; bool visited;}nodes[maxn*2+2];struct Edge { Node *from, *to; int capacity,flow; Edge *next, *reversedEdge; Edge(Node *from,Node *to,int capacity):from(from),to(to),capacity(capacity),flow(0),next(from-&gt;firstEdge){};};int n,m;inline void add(int a,int b,int c){ nodes[a].firstEdge = new Edge(&amp;nodes[a],&amp;nodes[b],c); nodes[b].firstEdge = new Edge(&amp;nodes[b],&amp;nodes[a],0); nodes[a].firstEdge-&gt;reversedEdge = nodes[b].firstEdge; nodes[b].firstEdge-&gt;reversedEdge = nodes[a].firstEdge;}struct Dinic{ bool makeLevelGraph(Node *s,Node *t, int n){ for(int i = 0 ;i&lt;n;i++) nodes[i].level = 0; queue&lt;Node*&gt;q; q.push(s); s-&gt;level = 1; while(!q.empty()){ Node* h = q.front(); q.pop(); for(Edge* e = h-&gt;firstEdge;e;e=e-&gt;next){ if(e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0){ e-&gt;to-&gt;level = h-&gt;level+1; if(e-&gt;to == t )return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s,Node *t,int limit = INT_MAX){ if(s == t)return limit; for(Edge *e = s-&gt;firstEdge;e;e = e-&gt;next){ if(e-&gt;to-&gt;level == s-&gt;level + 1 &amp;&amp; e-&gt;flow &lt; e-&gt;capacity){ int flow = findPath(e-&gt;to,t,min(limit,e-&gt;capacity-e-&gt;flow)); if(flow &gt; 0){ e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator ()(int s,int t,int n){ int ans = 0; while(makeLevelGraph(&amp;nodes[s],&amp;nodes[t],n)){ int flow; while(flow = findPath(&amp;nodes[s],&amp;nodes[t]) &gt; 0) ans += flow; } return ans; }}dinic;inline void printPath(Node *v){ cout&lt;&lt;v-&gt;id&lt;&lt;\" \"; v-&gt;visited = true; for(Edge *e = v-&gt;firstEdge;e;e=e-&gt;next){ if(e-&gt;flow == e-&gt;capacity &amp;&amp; e-&gt;to-&gt;id != 0 &amp;&amp; !nodes[e-&gt;to-&gt;id].visited){ printPath(&amp;nodes[e-&gt;to-&gt;id]); break; } }}int main(){ cin&gt;&gt;n&gt;&gt;m; const int s = 0,t = n*2+1; for(int i = 1;i &lt;= n; i++){ add(s,i,1), add(i+n,t,1); nodes[i].id = nodes[i+n].id = i; } for(int i = 0;i &lt; m;i++){ int u,v; cin&gt;&gt;u&gt;&gt;v; add(u,v+n,1); } int maxMatch = dinic(s,t,n*2+2); for(int i = 1;i &lt;= n;i++){ if(!nodes[i].visited){ printPath(&amp;nodes[i]); cout&lt;&lt;\"\\n\"; } } cout&lt;&lt;n-maxMatch;}","link":"/2020/02/11/网络流24题-最小路径覆盖问题/"},{"title":"网络流24题-魔术球问题","text":"（然后就鸽日更了23333 今天的题 思路：首先应该抽象出本题中隐藏的图： 图基于两个数之间的关系构造出（a + b = i * i 且a &lt; b 则从a到b有一条单向边） 那么一个柱子就相当于一条单向路径。 题目要求就变成了：给出路径数n，求其能覆盖到的最多节点数 就是最小路径覆盖问题的逆向解 如何逆向？ 考虑dinic+拆点。每次向网络中增加一个（一对）点，如果能找到增广路，说明其可以归到之前已有的某个路径中，此时不需要增加柱子，反之则需要增加柱子。 因为当有增广路时|G|与最大匹配数同时+1，此时最小路径覆盖不变。 |G| - 最大匹配数 = 最小路径覆盖 那么只需要每次加点后统计无法增广的次数N，N = n+1时得出的球数 ballNum - 1即是最大路径覆盖数 输出路径时只需要从每个路径的起点（加入后无法增广的点）遍历即可 需要注意的是：题目可能有多解 如上图的解就有： 1 8 2 7 9 3 6 10 4 5 11 1 3 6 10 2 7 9 4 5 11 8 而样例只给出了一种，实际上两种方案都可以AC 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;struct Node;struct Edge;const int maxn = 1e5;struct Node{ int id,level; Edge* head; bool visited;}nodes[maxn*2+2],S,T;struct Edge { int flow,capicity; Edge* reverseEdge,*next; Node *from,*to; Edge(Node* from,Node* to,int capa):from(from),to(to),capicity(capa),flow(0),next(from-&gt;head){};// 初始化flow=0};inline void add(Node* f,Node* t,int c){ f-&gt;head = new Edge(f,t,c); t-&gt;head = new Edge(t,f,0); //反向边容量0 f-&gt;head-&gt;reverseEdge = t-&gt;head; t-&gt;head-&gt;reverseEdge = f-&gt;head;}int n , m;struct Dinic{ bool makeLevelGraph(Node *s,Node *t,int n){ for(int i = 1;i &lt;= n;i++){ nodes[i].level = nodes[i+maxn].level = 0; } t-&gt;level = 0; t-&gt;id = 999; s-&gt;level = 1; queue&lt;Node*&gt; q; q.push(s); while(!q.empty()){ Node* h = q.front(); q.pop(); // cout&lt;&lt;\"head-&gt;\"&lt;&lt;h-&gt;id&lt;&lt;\"\\n\"; for(Edge* e = h-&gt;head;e;e=e-&gt;next){ if(e-&gt;to-&gt;level == 0 &amp;&amp; e-&gt;flow &lt; e-&gt;capicity){//两个条件：没有level、可增广 e-&gt;to-&gt;level = h-&gt;level+1; // cout&lt;&lt;e-&gt;to-&gt;id&lt;&lt;\"&lt;--\"&lt;&lt;h-&gt;level+1&lt;&lt;\"\\n\"; if(e-&gt;to == t){ return true; } else q.push(e-&gt;to); } } } return false; } int dfs(Node* s,Node* t ,int limit = INT_MAX){ if(s == t) return limit; for(Edge* e = s-&gt;head;e;e=e-&gt;next){ if(e-&gt;to-&gt;level == s-&gt;level+1 &amp;&amp; e-&gt;capicity &gt; e-&gt;flow){ int flow = dfs(e-&gt;to,t,min(limit,e-&gt;capicity - e-&gt;flow)); if(flow &gt; 0 ){ e-&gt;flow += flow; e-&gt;reverseEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator ()(Node* s,Node* t,int n){ int ans = 0; while(makeLevelGraph(s,t,n)){ int flow = 0; while(flow = dfs(s,t)&gt;0) ans += flow; } return ans; }}dinic;void printPath(Node* v){ cout&lt;&lt;v-&gt;id&lt;&lt;\" \"; v-&gt;visited = true; for(Edge* e = v-&gt;head;e;e=e-&gt;next){ if(e-&gt;flow == e-&gt;capicity &amp;&amp; !nodes[e-&gt;to-&gt;id].visited &amp;&amp; e-&gt;to-&gt;id!=0){ printPath(&amp;nodes[e-&gt;to-&gt;id&lt;&lt;1-1]); } }}int s[maxn];int main (){ int n; cin&gt;&gt;n; int stick = 0,ball = 0; while(stick &lt;= n){ ball++; nodes[ball].id = nodes[ball+maxn].id = ball; add(&amp;S,&amp;nodes[ball],1); add(&amp;nodes[ball+maxn],&amp;T,1); for(int i = sqrt(ball)+1;i &lt; sqrt(ball*2);i++){ add(&amp;nodes[(i*i-ball)],&amp;nodes[ball+maxn],1); // } int flow = dinic(&amp;S,&amp;T,ball); //每次增广 if(!flow){ // cout&lt;&lt;ball&lt;&lt;'\\n'; s[++stick] = ball; } } cout&lt;&lt;ball-1&lt;&lt;\"\\n\"; S.visited = true; T.visited = true; for(int i = 1;i &lt;= n ;i++){ printPath(&amp;nodes[s[i]]); cout&lt;&lt;\"\\n\"; } // 淦 多种方案 return 0;}","link":"/2020/02/13/网络流24题-魔术球问题/"},{"title":"[Android第一行代码]学习笔记","text":"aaaa冲oppo杯！ 第0章 – Kotlin变量val(value)用于声明不可变变量 var(variable)用于声明可变变量 显式声明Int类型变量：var:Int = 10 tips:优先使用val声明一个变量，不够用时才用var 函数示例： 123456fun methodName(param1:Int, param2:Int):Int{ return 0}// 语法糖：fun methodName(param1:Int, param2:Int) = max(param1,param2)// 自动类型推导并省略函数体 逻辑语句if与else一起使用时可以有返回值，返回值为代码块中最后一行代码的返回值。 1234567val value = if (num1 &gt; num2){ num1}else { num2}fun getMin(a:Int,b:Int) = if (a &lt; b) a else b when类似switch-case 123456fun getScore(name:String) = when (name){ \"Tommy\"-&gt;86 \"Jimmy\"-&gt;77 \"Jacky\"-&gt;95 else -&gt; 0} is 类型判断 1234567891011fun checkNum(num:Number) = when (num){ is Int -&gt; println(\"Int is incorrect\") is Double -&gt; ... else -&gt; ,,,}fun checkNum(num:Number) = when { num is Int -&gt; println(\"Int is incorrect\") num is Double -&gt; ... else -&gt; ,,,} for创建双端区间：val range = 0..10 创建单端闭区间：val range = 0 until 10 控制step：val range = 0 until 10 step 2 降序：downTo 面向对象123456789101112131415class Person(name:String){ var name = name fun eat(){ println(\"eating\") }}...var p = Person()//可继承:open class Person(){ ...}class Student: Person(){ ...} 为什么Person后要加括号？——主构函数和次构函数 主构函数： 123456789class Person(name:String){ init{ println(\"name is\"+ name) } var name = name fun eat(){ println(\"eating\") }} 继承时： 123456open class Person(name:String){ ...}class Student(name:String) : Person(name){ ...} 次构造函数：用于补充主构造函数 123class Student(name:String,val grade:Int) : Person(name){ constructor(name:String):this(name,0){}} 数据类： data class Cellphone(val brand:String,val price:Double) 自动生成equals(),hashCode(),toStirng() 单例类：(全局仅允许拥有一个实例) object class Singleton {} Lambda编程可变列表：mutableListOf() 不可变列表：listOf() 可用for-in遍历 set、map类似 lambda语法{参数名1：参数类型，参数名2：参数类型 -&gt; 函数体} 当只有一个参数时，参数名可以用it代替 val maxLengthFruit =- list.maxBy {it.length} val newList = list.filter {it.length &lt;= 5} . map{it.toUpperCase()} val anyResult = list.any {it.length &lt;= 5} val allResult = list.all {it.length &lt;= 5 } 空指针检查Kotlin默认所有指针和变量不可空 如果希望传入参数可以为空 12345fun doStudy(study: Study?){ if(study != null){ ... }} 允许为空时必须要对空类型进行处理（if …） 辅助判空工具（运算符） 1234fun doStudy(text: String?){ text?.doSomething() text?.length ?: 0} ?.运算符等价于上边的if判断 ?:左边表达式不为空时返回左边表达式结果，否则返回右边表达式的结果 !!非空断言，告诉编译器前面的对象不会为空 let()函数：将调用let函数的对象本身作为参数传入函数中 123456fun doStudy(study: Study?){ study.?let{ stu -&gt; stu.readBooks() stu.doHomeWork() }} 相比于用多个?.每次调用检查一次，?.let仅检查一次，效率更高 第一章0.项目文件结构项目结构模式 Android模式：适合快速开发 Project模式：真实文件结构 App目录下： libs：放置第三方jar包 androidTest：编写test用例 java：放置我们编写的java代码 res：放置图片、布局、字符串等资源，用于解决多分辨率设备的兼容性问题 只有一张图——放drawable-xxhdpi下 R.string.hello_world或者@string/hello_world方式都可以对res中的strings.xml的字符串进行引用 同理，引用图片就是@drawable，引用图标就是@mipmap @+id/button_1在xml中新定义一个id AndroidManifest.xml：（n.旅客名单）配置文件，用于注册组件（四大组件：Activity、Service、Content Provider、BroadcastReceiver），还可以给应用添加权限声明； test：用于编写Unit Test； proguard-rules.pro：用于指定打包时的混淆规则 逻辑与视图分离：布局文件都在res/layout路径下，通过setContentView()引用进来 1. 日志工具使用 例如：Log.d(tag:string, msg:string); 第一个参数为tag，一般传入当前类名，用于对打印信息进行过滤； 第二个参数msg，即想输出的错误信息； 与system.out.println()区别在于可控性 小trick：在onCreate外面输入logt可以自动生成TAG常量（类名），避免每次手动输入的麻烦； 可以通过左下角Logcat系统进行日志过滤； 第二章1. Activity活动 创建活动 通过setContentView()加载布局 在Manifest文件中注册（每次都会自动注册）&lt;application&gt;标签内 在&lt;activity&gt;中加入&lt;intent-filter&gt;，添加声明： 从而将当前活动设置为主活动（打开app首先启动的活动） 添加Toast： 布局中定义的元素可以通过findViewById(@id/xx)方法找到；方法本身返回一个View对象，可以向下转换为Button等对象； button对象通过setOnClickListener(Listener:View.OnClickListenter())方法绑定监听器。 Toast.makeText(context:Activity, msg:string, length:Toast.LENGTH_SHORT/Toast.LENGTH_LONG);显示Toast内容 使用Menu： 首先在res目录下新建一个menu文件夹，右键添加Menu源文件 每个item通过id指定标识符，title表示项名称 在活动中重写onCreateOptionsMenu(menu:Menu)、onOptionsItemSelected(item:Menuitem)方法。 销毁活动： 自动销毁：back 手动销毁：调用finish()方法 2. 使用Intent在活动中穿梭 显式intent： 构造意图（intent）：Intent(context:Context, cls:Class&lt;?&gt;)第一个参数表示想要启动新活动的上下文，第二个参数表示目标活动 通过startActivity(intent)实现意图 隐式intent： 不明确指出要启动的活动，只给出要启动的活动的要求（含蓄） 当前活动能够相应的action和category等信息都在配置文件中的intent-filter（名称由来），只有每种标签都匹配上才能相应； 还可以通过隐式Intent启动其他软件 还可以添加data标签，通过setData()方法传输数据；只有data标签和intent携带的data完全一致时才会进行响应。 还可以通过intent的putExtra(dataName:string, data)向下一个Activity传递数据；用intent = getIntent()+intent.getStringExtra(dataName)取出。 还可以通过startActivityForResult(intent:Intent, code)方法启动一个带有result存储器的活动，该活动通过setResult(code, intent:Intent)方法设置专门用于传输数据的intent，活动销毁之后，就可以通过原活动的onActivityResult(requestCode, resultCode, data:Intent)接受到下一个活动回传的数据。 例子： 原活动中： 目标活动中： 3. 活动的生命周期生命周期图示: onCreate()-onDestroy()：完整生存期。初始化-释放内存 onStart()-onStop()：可见生存期。期间应当管理用户可见的资源 onResume()-onPause()：前台生存期。例如Dialog会使其下层活动进入onPause() 使用Bundle的声明周期间数据保存方法： Bundle类提供一系列方法用于保存数据 回收前： 回收后： tips：可以用intent存储bundle对象进行数据传输。 4. 活动的启动模式：通过修改配置文件中&lt;activity&gt;项的android:launchMode改变活动启动模式 standard： 标准栈启动模式 singleTop： 不会重复创建栈顶活动 singleTask： 不会重复创建已经创建过的活动 singleInstance： 每次启动该活动会创建一个新的返回栈来管理活动 5. 活动最佳实践 使用BaseActivity继承AppComatActivity，定制BaseActivity的onCreate方法 其他子活动继承BaseActivity，即可看到当前活动名。 使用活动管理器进行活动管理： ​ BaseActivity中： 启用活动的最佳写法： 避免别的开发者要给你的活动传递数据时不清楚需要putExtra中写什么内容 在你的活动中添加： 这样其他活动要穿越到你的活动时只需要： 第三章1. 常用控件的使用方法 TextView android:id：每个控件都有的唯一标识符 android:layout_width/height：控件宽度/高度，可选值有match_parent、fill_parent、wrap_content前两者：继承父组件布局，后者：内容决定控件大小。 android:text：内容 android:gravity：指定文字对齐方式，可选:top/bottom/left/right/center/center_vertical/center_horizontal；可用|同时指定多个值。 android:textSize：文字大小，使用sp作为单位。dp、px区别：$px=dp\\times (dpi/160)$ $dpi = \\frac{\\sqrt{height^2+width^2}}{size（对角线长度）}$；dp、sp区别：dp不适配文字，sp还可以适配文字，因此多采用sp作为大小单位。 Button 实现监听方式： 匿名类 继承接口 EditText android:hint：提示字符 android:maxLines：指定最大行数，超过就会slide ImageView android:src=@drawable/xx：指定要显示的图片,可以通过setImageResource()方法进行动态修改； ProgressBar android:visibility：可选值：visible/invisible/gone表示可见/不可见/不可见且不再占用空间；可以使用setVisibility(View.VISIBLE/INVISIBLE/GONE)方法进行设置；默认圆形进度条，可以设置style=&quot;?android:attr/progressBarStyleHorizontal&quot;改为水平进度条，然后设置android:max=&quot;100&quot;进度条最大值为100，通过方法getProgress()/setProgress()更改进度条的进度。 AlertDialog 弹出一个屏蔽掉其他控件的对话框，用于提示重要的内容或警告信息。 类似的还有ProgressDialog，用于提示进度。不同的是如果在setCancelable()时传入False，则不能通过back键取消掉。此时必须要在恰当的时候调用dismiss()方法来关闭对话框。 2. 详解4种基本布局​ 布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置。 LinearLayout线性布局 所有控件在线性方向上垂直排列，可以通过android:orientation=&quot;vertical/horizontal&quot;设置； 需要注意的是，如果设置为horizontal水平，就不能把子控件宽度设置为match_parent,否则单独一个控件将会把整个水平方向占满。 android:layout_gravity用于指定布局的对齐方式，需要注意不能与线性方向冲突，否则会失效；可以用|连接； android:layout_weight使用在线性方向上用比例方式指定控件的大小，例如有两个button的weight都是1，则他们每个的宽度就是$ \\frac{1}{2} $；若只指定部分控件的weight，则被指定的控件的”1”=总宽度-未指定weight控件的宽度。 RelativeLayout相对布局 可通过相对定位的方式让控件出现在布局的任何位置 各种属性： 相对于父组件的： layout_alighParentLeft/Top/Right/Bottom/centerInParent 相对于兄弟组件的： layout_above/toLeftOf/below/toRightOf=&quot;@id/xx&quot; FrameLayout帧布局 默认摆放在左上角 默认情况下多个组件会叠加在左上角 可以通过layout_gravity属性指定对齐方式 PercentFrameLayout百分比布局 不需要指定控件大小，直接按比例指定控件所占布局的百分比； 需要先导入依赖 继承了Frame的属性，默认左上角；因此还有PercentRelativeLayout可用。 3. 自定义控件 自定义布局（避免重复创建布局）： 引用一个actionBar 新建一个布局文件title.xml 在其他xml文件中&lt;include layout=”@layout/title”/&gt;即可 自定义控件（避免重复创建监听响应代码） 新建TitleLayout继承LinearLayout inflate()加载动态布局文件R.layout.title 注册onClick 4. ListView","link":"/2020/10/31/Android第一行代码-学习笔记/"},{"title":"React学习笔记","text":"React 中的响应式设计思想只需要关注数据变化，而不用关注dom变化； react自动感知数据变化，自动修改dom（自动响应（React））； 数据需要定义在组件的状态中； 数据绑定组件state中变量与input标签的value绑定 双向绑定 = 单向绑定 + UI事件监听 事件绑定onChange={this.handler} 事件e.target属性代表绑定的dom handler的本身this是undefined（因为直接调用了该函数），可以用.bind(this)在constructor中绑定本组件的this以节省性能 this.state需要使用this.setState传入对象修改才会将修改更新到dom 视图层框架只负责数据和页面渲染，需要配合数据层框架来解决传值问题，因此react定位为视图层框架 props，state，render组件的props/state发生改变时，render会重新执行 父组件执行render，子组件render也会被执行 组件意义页面大且复杂，拆成小的部分逻辑更简单 拆分组件过大时进行拆分 父组件向子组件传值： 直接传递props 子组件向父组件传值： 父组件向子组件传递方法 子组件进行调用 需要绑定函数this指向父组件 单向数据流子组件仅使用而不能直接修改父组件中数据，方便定位数据调试 PropTypes&amp;DefaultProps PropTypes用于校验从父组件传入的值的类型 defaultProps用于设置组件默认props Virtual DOMVDOM：用JS对象描述的真实DOM 根据VDOM生成真实DOM state发生变化时生成新的VDOM 比较新旧VDOM的区别，找到发生变化的内容，操作JS对象之间效率比直接操作对比真实DOM高得多 直接操作DOM，更新span中内容 JSX -&gt; JS obj -&gt; real DOM createElement(标签，属性，内容) diff算法 setState是异步函数，连续调用会合成一个diff并更新 同层比对，只要发现不同即重新渲染整个子树，减少算法比对性能消耗 通过选取前后不变的key可以增加重新渲染效率，不要用index做key，因为重新渲染会改变原本index ref的使用&lt;input ref={(input)=&gt;{this.input = input}}/&gt; 相当于在组件中添加input成员作为input标签的引用，可以替代e.target 回调函数——函数执行完毕返回时调用的函数 React生命周期函数 生命周期函数指在某一特定时刻组件自动调用的函数。 componentWillMount()：在组件挂载到页面前执行 componentDidMount()：在组件挂载到页面之后执行，where commonly placed ajax componentWillReceiveProps()：在组件接受到父组件的props，且父组件重新执行render shouldComponentUpdate(nextProps,nextState)：参数中包含新的props和states，通过设置返回false or true来控制子组件是否需要随父组件更新 Redux思想Store负责管理、分配组件需要使用的数据 Redux = Reducer + Flux workflow dispatcher通过将不同的action传入reducer，reducer根据oldState返回给store新的state，store进行数据更新 1234567891011121314151617181920212223242526272829303132// store/index.js// 创建store并绑定对应的reducerstore = createStore(reducer);// store/reducer.js reducer(state,action){ if(action.type === &apos;xxx&apos;) // 不可以修改state 只能使用state的值 // 复制一份 newState = JSON.parse(JSON.stringify(state)); return newState; } // in component constructor(props){ super(props); ... store.subscribe(this.handleStoreChange); // 订阅 } handleInputChange = (e) =&gt;{ const action = { type=&apos;&apos;; // 必须 可以拆分到store/actionTypes.js方便调试 value=&apos;&apos;; // 非必须 } store.dispatch(action); // 用action更新store } handleStoreChange = (e)=&gt;{ // 订阅之后state发生变化时将自动执行 this.setState(store.getState()); // 重新从store中取数据替换组件当前数据 } 使用actionCreator统一管理创建action: 123456789// store/actionCreators.jsgetInputChangeAction = (value)=&gt;{ type: CHANGE_INPUT_VALUE, value}// in componenthandler(e) { store.dispatch(getInputChangeAction(e.target.value));} Redux原则： store是唯一的 只能store自己改变自己的内容 reducer必须是纯函数（有固定输入就有固定输出，且不会有side effect） UI组件、容器组件、无状态组件UI组件处理页面渲染，容器组件处理页面逻辑 无状态组件性能高，仅通过一个包含props的函数就可生成 UI组件可以通过无状态组件实现 React-thunk中间件中间件 方式异步请求移到ActionCreator 创建Store时使用applyMiddleware 1createStore(reducer, applyMiddleware(thunk)); 使用时 123456789101112131415//store/actionCreators.jsconst initial = ()=&gt;{ return (dispatch)=&gt;{ axio.get(...).then((res)=&gt;{ const data = res.data; const action = ... dispatch(action); }) }}//index.jscomponentDidMount(){ const init = initial(); store.dispatch(init);} 只有import了thunk，store.dispatch()的参数才可以是函数，并且自动将dispatch函数传入作为参数 相当于把store.dispatch和参数action之间加了一层中间层，对store的dispatch方法进行了封装 React-saga中间件方法takeEvery(&quot;ACTION_TYPE&quot;,Generator)：监听到action，执行对应的函数 put：相当于store.dispatch generator处理axio失败情况：try catch捕获异常 saga可以将所有异步请求拆分到同一个文件里，适合大型项目； thunk增加了dispatch的类型，将异步请求拆分到actionCreator中 React-Redux 用Provider包裹根节点，将数据提供给子树下所有节点，但需要保证Provider仅包裹一个节点 connect方法，两个参数connect(mapStateToProps,mapDispatchToProps)(Component) mapStateToProps(state)：默认接受state作为参数，将Store中state映射为本组件的props mapDispatchToprops(dispatch)：默认接受dispatch做参数，将store.dispatch挂载到组件的props上 现在可以不用subscribe了 使用connect相当于将业务逻辑拆分出来，导出了容器组件 reducer可以拆分到组件对应的文件夹下，用combineReducers合并 实战sytle-Componenets &amp; reset.css直接import css会应用到该组件下所有标签 使用style-componenets可以将作用域限制在本组件范围内，避免多组件CSS冲突 reset.css可以统一不同浏览器中同名标签的不同样式 拆分actionCreator、reducer将actionCreator、reducer以及actionType常量可以都放到组件store文件夹下，并通过index.js暴露接口给外部 immutableimmutable.fromJS({})将JS对象转化为immutable对象，不可修改，内部数组会变成immutable数组 通过get(attrName)方法获取对象内容，set(attrName，value)方法返回修改后的新对象 redux-immutable库中的combineReducers可以返回immutable对象 store.get(&quot;header&quot;).get(&quot;focus&quot;) === store.getIn([&quot;header&quot;,&quot;focus&quot;]) 路由第三方库: react-router-dom BrowserRouter、Route标签 BrowserRouter和Provider类似，也需要保证仅包裹了一个标签 &lt;Route path=&quot;/&quot; render={()=&gt;{&lt;div&gt;}}&gt; 当出现“/”路径就显示div &lt;Route path=&quot;/&quot; exact render={()=&gt;{&lt;div&gt;}}&gt;仅出现“/”路径才显示div 动态路由： Link标签加上to={‘/detail/‘+id} 主路由Route path 加上额外参数/:id 通过参数传递： Link标签加上to={‘detail?id=’+id} 不影响原来Route path的匹配 参数?id=x在props.location.search中 withRouter export时包裹组件withRouter(Component)，用来获取history、location、match三个对象传入props对象上； 路由组件可以直接获取这些属性，而非路由组件就必须通过withRouter修饰后才能获取这些属性，例如： 1&lt;Route path=&apos;/&apos; component={App}/&gt; App组件就可以直接获取路由中这些属性了，但是，如果App组件中如果有一个子组件Foo，那么Foo就不能直接获取路由中的属性了，必须通过withRouter修饰后才能获取到。 其他 dangerouslySetInnerHtml dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供 innerHTML 的替换方案。通常来讲，使用代码直接设置 HTML 存在风险，因为很容易无意中使用户暴露于跨站脚本（XSS）的攻击。因此，你可以直接在 React 中设置 HTML，但当你想设置 dangerouslySetInnerHTML 时，需要向其传递包含 key 为 __html 的对象，以此来警示你。 异步组件 按需加载组件，提升加载速度 第三方库：react-loadable","link":"/2021/01/23/React学习笔记/"},{"title":"Tkinter+Graphviz+Swig|如何用Python调用c++接口实现跳表结构动态展示GUI","text":"Step0: 分析需求由于要求使用C++编写核心代码 /挠头，而我又不咋会用QT，看了一下QT的教程感觉也代码量++，所以就没选QT写图形界面。但是如果用D3.js的话又会有一堆c++源码与js通信之类的问题。直到我发现了swig—— Step1：在Python中使用C++：用Swig封装C++源码Swig简介Swig（Simplified Wrapper and Interface Generator）安装与使用非常（相对来说）方便： SWIG (Simplified Wrapper and Interface Generator) 简单的包装和接口生成器 SWIG 可以 把C++代码封装成Python库 SWIG 实际上是一个编译器，获取C/C++的声明，用一个壳包起来，以便通过其他语言访问这些声明。 下载 文档 下载解压加Path一气呵成 具体流程：1. 编写C/C++文件推荐.h文件声明+.c/.cpp文件实现，这样后边写接口文件会方便一些。 例如： 123456789101112131415161718192021222324252627282930313233// skipList.h#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;struct skipNode{ pair&lt;int,string&gt; element; skipNode** next; int level; skipNode(); skipNode(pair&lt;int,string&gt; element,int nextSize);};class SkipList{ private: skipNode* headNode,*tailNode; int tailKey ; skipNode** last; int cutoff,maxLevel; int maxKey; skipNode* search(int key); public: int dSize;int levels; SkipList(int largeKey,int maxPairs, double prob); int makeLevel() const; void insert(const pair&lt;int,string&gt; element); skipNode find(int key); void erase(int key); void eraseMin(); void eraseMax(); vector&lt;skipNode&gt; getKeyList();}; 实现文件skipList.cpp太长就不贴了 2. 编写.i 接口文件swig需要使用.i接口文件进行对接 1234567891011// skipList.i%module skipList%include &quot;std_pair.i&quot;%include &quot;std_string.i&quot;%include &quot;std_vector.i&quot;%{#include &quot;skipList.h&quot;%}%include&quot;skipList.h&quot;%template(make_pair) pair&lt;int,string&gt;;%template(vec) vector&lt;skipNode&gt;; 这个文件的编写规范在Swig-C++文档里可以查到。 这里因为使用了pair/string/vectorSTL的内容所以需要前面include三个预置的.i文件 %module后面的名字是被封装的模块名称，Python通过这个名称加载程序。 %{...%}之间是函数声明和头文件。 最后一部分，声明了要封装的函数和变量，一般来说直接include .h文件就可。 但是这里我增加了pair&lt;int,string&gt; 和 vector&lt;skipNode&gt;两个特化模板类，因为后续Python中需要调用这两个东西(pair用于插入、vector用于遍历跳表) 这里可以注意到接口文档中所有的模板类都需要特化之后才能编进包内。思考一下原因应该就是：swig没法支持在Python中再进行模板的实例化，因此需要提前指定好模板类型。 3. 调用Swig产生python模块确认添加完环境变量，把.i .c .cpp 文件放在同一个目录下后，可以直接在该目录的powerShell下输入如下指令 1Swig -c++ -python skipList.i 当然如果是c文件就不用加 -c++选项了 如果没有报错的话，你会发现同级目录下多出了三个文件 _skipList.cp37-win_amd64.pyd skipList.py skipList_warp.cxx 这个skipList.py就是我们要用的库，但是现在里边应该没什么东西。 然后进入下一步： 4. 利用distutils生成动态库新建一个setup.py 12345678910111213from distutils.core import setup, ExtensionskipList_module = Extension('_skipList', sources=['skipList_wrap.cxx', 'skipList.cpp'], )setup(name='skipList', version='0.1', author=\"SWIG Docs\", description=\"\"\"skipList package\"\"\", ext_modules=[skipList_module], py_modules=[\"skipList\"], ) 然后编译生成 1python setup.py build_ext --inplace 对了，顺带提一句，我的python版本是3.7 然后如果你跟我一样电脑从来没有装过VS的任何版本的话，你将会收到报错： 1error: Unable to find vcvarsall.bat 原因具体见：在安装Python包的时候报错：error: Unable to find vcvarsall.bat的解决办法 大概意思就是缺少把c++编译成python包的文件，这个文件swig没有，必须到VS家下，当然也可以不装VS只装个工具集就ok。 python3.5+的版本 Visual C++ Build Tools 2015 其他版本到上边那个文章里面找就可以了。 装完之后重新输入上边的指令。看到 1Finished generating code 就说明你的c++包已经成功编成python扩展包了 你可以试用一下： 123456from skipList import SkipList,pairis,skipNode,vecskp = SkipList(1000,1000,0.5)skp.insert(make_pair(1,\"this is a value\"))node = skp.getKeyList()for node in nodes : print(node.element.first+\",\"+node.element.second) 这样应该能得到输出 11,this is a value 如果你尝试直接输出一下node，你将会得到： 1&lt;skipList.skipNode; proxy of &lt;Swig Object of type &apos;skipNode *&apos; at 0x0000022302E84540&gt; &gt; 因为node在c++中vector&lt;skipNode&gt;类型的变量，因此swig对其进行了封装，不能直接输出，但是依然可以通过成员/方法调用。 以上是c++核心代码封装成python包的过程。 参考:这篇博客 所以又回到了开始的问题：我为啥不用QT？ Step2：图怎么画？利用Graphviz Dot画跳表Graphviz介绍图形可视化是一种将结构信息表示为抽象图形和网络图的方式。Graphviz是大名鼎鼎的贝尔实验室的几位牛人开发的一个画图工具。可以通过dot文件提供的结构信息直接生成对应的图形。 使用Graphviz绘制图形Graphviz使用的dot文件十分简单易懂：一个图应该只包含点、边。那么一个最简单的图应该就是这样： 它的源码是这样： 123digraph G{ hello-&gt;world;} 当然可以通过给点和边赋予不同的属性值，调整颜色、标签、内容、样式等等。 比如，一个复杂一点的哈希表： 123456789101112131415161718192021222324252627digraph g { nodesep = .05; rankdir = LR; //规定了图的方向-&gt;左到右 node[shape = record, width = .1, height = .1]; // 节点的形状是“record”（方形） node0[label = &quot;&lt;f0&gt; |&lt;f1&gt; |&lt;f2&gt; |&lt;f3&gt; |&lt;f4&gt; |&lt;f5&gt; |&lt;f6&gt; |&quot;, height = 2.5]; //我是一个节点, 我有8个格，前7个可以被引用 node [width = 1.5]; node1[label = &quot;{&lt;n&gt; n14 | 719 |&lt;p&gt;}&quot;]; //我还是一个节点, 有横向的三个格子，前后的格子都可以被引用 node2[label = &quot;{&lt;n&gt; a1 | 719 |&lt;p&gt;}&quot;]; node3[label = &quot;{&lt;n&gt; i9 | 512 |&lt;p&gt;}&quot;]; node4[label = &quot;{&lt;n&gt; e5 | 632 |&lt;p&gt;}&quot;]; node5[label = &quot;{&lt;n&gt; t20 | 959 |&lt;p&gt;}&quot;]; node6[label = &quot;{&lt;n&gt; o15 | 794 |&lt;p&gt;}&quot;]; node7[label = &quot;{&lt;n&gt; s19 | 659 |&lt;p&gt;}&quot;]; //好了, 我开始连接了 node0:f0-&gt;node1:n; // node0的f0位置连到node1的n位置 node0:f1-&gt;node2:n; node0:f2-&gt;node3:n; node0:f5-&gt;node4:n; node0:f6-&gt;node5:n; node2:p-&gt;node6:n; node4:p-&gt;node7:n;} 使用Graphviz绘制跳表基（yao）本（yong）的语法大概看懂了，够用了。那么如何用Graphviz绘制成跳表呢？ 根据规律每次生成一份dot文件倒是也行，不过源码里估计也是一堆string不能看了。 灵机一动，反正也是用python搞，万一有现成的包什么的呢？ 然后就找到了这个：python-graphviz API文档 (不愧是本世纪第一脚本语言哈哈哈哈生态果然好) 就开始画呗。稍微理顺一下跳表的画图思路： 首先得把图的所有节点以及每个节点的指针层数整出来 每层的前一个节点连到后一个节点的对应位置 每个节点的命名应该是独立的，所以直接用节点key值是最合适的 头尾节点指针层数取所有节点的Max 按照上述思路，写了一份还算简短的绘图代码： 1234567891011121314151617181920212223242526def reDraw(self): # 实例化一个Digraph对象(有向图)，name:生成的图片的图片名，format:生成的图片格式 dot = Digraph(name=\"pic\", comment=\"skipList\", format=\"png\",graph_attr={(\"rankdir\",\"LR\")},node_attr={(\"shape\",\"record\")}) hlabel = \"head\" tlabel = \"tail\" last = [] # 用这个记录每层最后一个节点的名字（key） for i in range(0,self.skipList.levels+1): hlabel = \"&lt;l\" + str(i) + \"&gt;|\" + hlabel # 应该是一层层倒着摞上去 tlabel = \"&lt;l\" + str(i) + \"&gt;|\" + tlabel last.append(-1) size = 2147483647 dot.node(name=\"-1\",label=hlabel) dot.node(name=str(size),label=tlabel) nodes = self.skipList.getKeyList() # 得到所有节点的接口 for node in nodes: label = str(node.element.second) i = node.element.first # 节点key值 for j in range(0,node.level+1): label = \"&lt;l\" + str(j) + \"&gt;|\" + label dot.node(name=str(i),label=label) for j in range(0,node.level+1): dot.edge(str(last[j])+\":l\"+str(j),str(i)+\":l\"+str(j)) last[j] = i for i in range(0,self.skipList.levels+1): dot.edge(str(last[i])+\":l\"+str(i),str(size)+\":l\"+str(i)) dot.render(filename='pic',view=False) 最后我们直接可以用dot.render()方法生成图片，从而跳过输出源码再编译生图这一步转化。 效果图： Graphviz不止于此，有兴趣的同学可以去Graphviz官网康康其他图的demo。 参考：利用Graphviz Dot绘图 Graphviz-Graph Visualization Software Step3：挑一个GUI库吧！Tkinter 的使用既然前面两个都用到python了，那么我们继续用python做GUI咯 需求分析 这是课设里的基本要求，当然也就是我们的需求： 输入框，用于输入需要插入/删除/查找的key和value，当然前面应该有提示信息 几个button，与插入删除查找函数绑定 显示框，每次操作后调用新生成跳表的图片 显示框，显示历史，记录操作后显示进行的操作以及运行时间等信息 用Tkinter实现需求（python的GUI接口果然简单Max分分钟构建GUI） 注：图片显示使用的文件需要写到类成员中，不然每次生成图片之后局部变量自动清空图片也就没了。 参考：tkinter教程 python打开网络图片并缩放 Step4：组合！那么我们动态展示的思路就差不多了： 编写C++核心源码，用swig生成python包并调用 在py文件中实例化一个skipList类 通过GUI与用户交互从而获得数据，利用数据进行skipList的一系列操作 对于每次交互得到一个skipList的状态，利用其重新构建dot文件并生成图片并显示 完成！Python真香！","link":"/2020/03/07/Tkinter-Graphviz-Swig-如何用Python调用c-接口实现跳表结构动态展示GUI/"},{"title":"从hexo部署成功后不显示新文章看http缓存","text":"震惊！hexo部署完成后网页却还是显示上一次更新的内容，hexo clean也不好用！ 竟然跟http缓存有千丝万缕的关系！ 寻找原因hexo clean？之前有过hexo g后发现并没有更新，重新尝试hexo clean清除缓存和静态文件之后解决的问题 但这次不一样，本地生成部署完毕之后在archives里能看到，但是首页却不显示。 且hexo s在本地服务器查看的话新文章是存在的。 因此不是hexo clean能解决的问题 原因抓个包： 发现全都是from disk cache以及from memory cache 也就是说所有都是在客户端缓存请求的，浏览器实际并没有发送http请求给服务器去更新Home列表。 所以我们就找到原因了： 因为最近有使用浏览器访问过，并且客户端将内容都进行了缓存，而此时缓存还未过期我们就进行了新内容的部署，因此出现了上述问题。 那么我们应该首先搞清楚缓存。 缓存缓存过程分析浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个阶段，分别是强制缓存和协商缓存。 强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下： 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图： 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图 那么强制缓存的缓存规则是什么？ 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。 ExpiresExpires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。 Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？ 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？ Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效 接下来，我们直接看一个例子，如下： 由上面的例子我们可以知道： HTTP响应报文中expires的时间值，是一个绝对值 HTTP响应报文中Cache-Control为max-age=600，是相对值 由于Cache-Control的优先级比expires高，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。 注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。 了解强制缓存的过程后，我们拓展性的思考一下： 浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？ 这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。 那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？ from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。 虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析： 访问https://heyingye.github.io/ –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开https://heyingye.github.io/ –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache) 过程如下： 访问https://heyingye.github.io/ 关闭博客的标签页 重新打开https://heyingye.github.io/ 刷新 看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？ 对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下: 内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性： 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。 时效性：一旦该进程关闭，则该进程的内存则会清空。 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304 Not Modified，表示资源没有更新 缓存失效，返回200和更新后的请求结果 同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。 Last-Modified / If-Modified-SinceIf-Modified-Since则是客户端发起request时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。 Last-Modified是服务器response时，返回该资源文件在服务器最后被修改的时间，如下。 Etag / If-None-MatchIf-None-Match是客户端发起request时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。 Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。 可以看出，Expires与Last-Modified / If-Modified-Since也是使用时间戳的方式进行新鲜度判断。 而Etag / If-None-Match则是使用生成唯一编号的方式。 因此，Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。 总结强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下： 问题解决搞清楚了http的缓存过程，那么我们很容易就能解决我们的问题了。 最简单的方法：ctrl+F5强制刷新，这时候会在headers中加上cache-control:no-cache字段，表示强制确认缓存，并非不使用缓存 也可以修改hexo主题文件夹里的 head 文件的 meta 标签，来添加一个Cache-Control首部no-cache，不过不建议这样做，这样会让浏览器每次都会发送请求去确认缓存是否在服务器有更新（协商缓存），这样会多了很多不必要的 HTTP 请求和一些资源的下载，这些都会造成页面加载时间过久，影响体验，所以，还是每次部署后直接强制刷新页面来得更加简单有效率. 可以手动清除storage中的数据，Chrome 打开控制台Application,点击clear site data清除站点数据，然后刷新，应该就会出现最新页面了。 参考链接：https://juejin.im/entry/5ad86c16f265da505a77dca4","link":"/2020/03/31/从hexo部署成功后不显示新文章看http缓存/"},{"title":"程设Week10-作业+模拟","text":"模拟——人生之敌 A- CodeForces - 1141A 题目描述东东在玩游戏“Game23”。 在一开始他有一个数字n，他的目标是把它转换成m，在每一步操作中，他可以将n乘以2或乘以3，他可以进行任意次操作。输出将n转换成m的操作次数，如果转换不了输出-1。 输入输入的唯一一行包括两个整数n和m（1&lt;=n&lt;=m&lt;=5*10^8). 输出输出从n转换到m的操作次数，否则输出-1. 题目分析 如果可以转换，那么n必然是m的因子，有n*k=m 那么k的因子必然有且只有2和3，可以循环除两波 否则转换不了（最终k=1） 代码12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; if(m%n != 0){ cout&lt;&lt;-1; }else { int cnt = 0,k=m/n; while(k%2 == 0 &amp;&amp; k!=0){ k/=2;cnt++; } while(k%3 == 0 &amp;&amp; k!=0){ k/=3;cnt++; } if(k!=1) cout&lt;&lt;-1; else cout&lt;&lt;cnt; }} B - LIS &amp; LCS题目描述东东有两个序列A和B。 他想要知道序列A的LIS和序列AB的LCS的长度。 注意，LIS为严格递增的，即a1&lt;a2&lt;…&lt;ak(ai&lt;=1,000,000,000)。 输入第一行两个数n，m（1&lt;=n&lt;=5,000,1&lt;=m&lt;=5,000）第二行n个数，表示序列A第三行m个数，表示序列B 输出输出一行数据ans1和ans2，分别代表序列A的LIS和序列AB的LCS的长度 题目分析 LIS的转移方程：$ dp[i] = max(dp[i],dp[j] + 1);$ 其中dp[i]表示到以第i个位置的数为结尾的LIS，因此过程中应当记录最大值为最终答案。且dp数组应初始化为1 LCS的转移方程： a[i] == b[j] $dp[i][j] = max(dp[i-1][j-1]+1,dp[i][j])$ a[i] != b[j] $dp[i][j] = max(dp[i-1][j],dp[i][j-1])$ dp[i][j]表示第一个序列的0-i和第二个序列的0-j构成的LCS，答案直接取dp[n][m]即可 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int maxx = 5e3+10;int a[maxx],b[maxx];int dp1[maxx],dp2[maxx][maxx];int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;a[i]; dp1[i] = 1; } for(int i = 1;i&lt;=m;i++){ cin&gt;&gt;b[i]; } int ans1 = 0; for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;i;j++){ if(a[i] &gt; a[j]) dp1[i] = max(dp1[i],dp1[j] + 1); } ans1 = max(ans1,dp1[i]); } for(int i = 1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if(a[i] == b[j]){ dp2[i][j] = max(dp2[i-1][j-1]+1,dp2[i][j]); }else { dp2[i][j] = max(dp2[i-1][j],dp2[i][j-1]); } } } cout&lt;&lt;ans1&lt;&lt;\" \"&lt;&lt;dp2[n][m]; return 0;} C - 拿数问题 II题目描述给一个序列，里边有 n 个数，每一步能拿走一个数，比如拿第 i 个数， Ai = x，得到相应的分数 x，但拿掉这个 Ai 后，x+1 和 x-1 (如果有 Aj = x+1 或 Aj = x-1 存在) 就会变得不可拿（但是有 Aj = x 的话可以继续拿这个 x）。求最大分数。 输入第一行包含一个整数 $n (1 ≤ n ≤ 10^5)$，表示数字里的元素的个数 第二行包含n个整数$a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5)$ 输出输出一个整数n：你能得到最大分值。 题目分析 相当于把之前的位置变成了数字大小，本质是一样的。显然拿某个数就可以把相等的其他数全都拿走； 读入一个x时，将其加入a[x]桶里，也就是说，最终拿走每个数的分值就是a[x]； 转移方程：$dp[i] = max(dp[i-1],dp[i-2]+a[i])$ dp[i]表示取到第i个位置的最大得分是多少； 代码1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxx = 1e7+10;long long a[maxx],dp[maxx];int main(){ int n; cin&gt;&gt;n; int l = 21474836,r = 0; for(int i = 1;i&lt;=n;i++){ int k; cin&gt;&gt;k; a[k] += k; l = min(l,k); r = max(k,r); } dp[l] = a[l]; dp[l+1] = max(a[l],a[l+1]); for(int i = l+2;i &lt;= r ;i++){ dp[i] = max(dp[i-1],dp[i-2]+a[i]); } cout&lt;&lt;dp[r]; return 0;} 限时模拟A - 签到题题目描述TT有一个A×B×C的长方体。这个长方体是由A×B×C个1×1×1的小正方体组成的。 现在TT想给每个小正方体涂上颜色。 需要满以下三点条件： 每个小正方体要么涂成红色，要么涂成蓝色。 所有红色的小正方体组成一个长方体。 所有蓝色的小正方体组成一个长方体。 现在TT想知道红色小正方体的数量和蓝色小正方体的数量的差异。 你需要找到红色正方体的数量与蓝色正方体的数量差值的绝对值的最小值。即min{|红色正方体数量 - 蓝色正方体数量|}。 输入输入仅一行，三个数A B C (2≤A,B,C≤10^9)。 输出输出一个数字。 即差值绝对值的最小值。 题目分析 注意 原来的ABC长方体不能拆开 如果ABC某个是2的倍数，直接对半开就可 否则要满足要求，则两种颜色的正方体数肯定要相差一个面的正方体数，那么求最小的面大小就可； 代码123456789101112#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main(){ long long a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a%2 == 0 || b%2 == 0 || c%2 == 0){ cout&lt;&lt;0; }else { cout&lt;&lt;min(a*b,min(b*c,c*a)); }} B - 团 队 聚 会 （不支持C++11）题目描述TA团队每周都会有很多任务，有的可以单独完成，有的则需要所有人聚到一起，开过会之后才能去做。但TA团队的每个成员都有各自的事情，找到所有人都有空的时间段并不是一件容易的事情。 给出每位助教的各项事情的时间表，你的任务是找出所有可以用来开会的时间段。 输入第一行一个数T（T≤100），表示数据组数。 对于每组数据，第一行一个数m（2 ≤ m ≤ 20），表示TA的数量。 对于每位TA，首先是一个数n（0≤ n≤100），表示该TA的任务数。接下来n行，表示各个任务的信息，格式如下 1YYYY MM DD hh mm ss YYYY MM DD hh mm ss &quot;some string here&quot; 每一行描述的信息为：开始时间的年、月、日、时、分、秒；结束时间的年、月、日、时、分、秒，以及一些字符串，描述任务的信息。 数据约定： 所有的数据信息均为固定位数，位数不足的在在前面补前导0，数据之间由空格隔开。 描述信息的字符串中间可能包含空格，且总长度不超过100。 所有的日期时间均在1800年1月1日00:00:00到2200年1月1日00:00:00之间。 为了简化问题，我们假定所有的月份（甚至2月）均是30天的，数据保证不含有不合法的日期。 注意每件事务的结束时间点也即是该成员可以开始参与开会的时间点。 输出对于每一组数据，首先输出一行”Scenario #i:”，i即表明是第i组数据。 接下来对于所有可以用来开会的时间段，每一个时间段输出一行。 需要满足如下规则： 在该时间段的任何时间点，都应该有至少两人在场。 在该时间段的任何时间点，至多有一位成员缺席。 该时间段的时间长度至少应该1h。 所有的成员都乐意一天24h进行工作。 举个例子，假如现在TA团队有3位成员，TT、zjm、hrz。 那么这样的时间段是合法的：会议开始之初只有TT和zjm，后来hrz加入了，hrz加入之后TT离开了，此后直到会议结束，hrz和zjm一直在场。 要求： 输出满足条件的所有的时间段，尽管某一段可能有400年那么长。 时间点的格式为MM/DD/YYYY hh:mm:ss。 时间段的输出格式为”appointment possible from T0 to T1”，其中T0和T1均应满足时间点的格式。 严格按照格式进行匹配，如果长度不够则在前面补前导0。 按时间的先后顺序输出各个时间段。 如果没有合适的时间段，输出一行”no appointment possible”。 每组数据末尾须打印额外的一行空行。 题目分析 将所有出现的时间点（时刻）投射到一个时间轴上，每两个时间点之间构 成一个足够小的区间（左开右开），可以用set实现，也可以不去重直接排序。 逐次判断每个区间是否合法，标记所有合法的区间。 合并所有相邻的区间，判断合并后的区间长度是否合法。 输出所有合法的区间。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;struct TimeNode { int year, month, day; int hour, minute, second; TimeNode() {} TimeNode(int a, int b, int c, int d, int e, int f) { year = a; month = b; day = c; hour = d; minute = e; second = f; } TimeNode(int *a) { year = a[0]; month = a[1]; day = a[2]; hour = a[3]; minute = a[4]; second = a[5]; } TimeNode operator=(const TimeNode &amp;b) { year = b.year; month = b.month; day = b.day; hour = b.hour; minute = b.minute; second = b.second; } bool operator&lt;(const TimeNode &amp;b) const { if (year != b.year)return year &lt; b.year; if (month != b.month)return month &lt; b.month; if (day != b.day)return day &lt; b.day; if (hour != b.hour)return hour &lt; b.hour; if (minute != b.minute)return minute &lt; b.minute; return second &lt; b.second; } bool operator&gt;(const TimeNode &amp;b) const { return b &lt; *this; } bool operator&lt;=(const TimeNode &amp;b) const { return !(b &lt; *this); } bool operator&gt;=(const TimeNode &amp;b) const { return !(*this &lt; b); } bool operator==(const TimeNode &amp;b) const { return !(b &lt; *this || *this &lt; b); } bool operator!=(const TimeNode &amp;b) const { return b &lt; *this || *this &lt; b; } void Output() { cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; month &lt;&lt; '/'; cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; day &lt;&lt; '/'; cout &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; year &lt;&lt; ' '; cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; hour &lt;&lt; ':'; cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; minute &lt;&lt; ':'; cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; second; }};int n;set&lt;TimeNode&gt; s;vector&lt;TimeNode&gt; Node;vector&lt;pair&lt;TimeNode, TimeNode&gt; &gt; A[22], Ans;//清空函数void clr(int n) { s.clear(); Ans.clear(); Node.clear(); for (int i = 0; i &lt;= n; ++i)A[i].clear();}bool checkPer(int id, TimeNode l, TimeNode r) { for (int i = 0; i &lt; A[id].size(); ++i) { if (l &gt;= A[id][i].first &amp;&amp; r &lt;= A[id][i].second)return 0; } return 1;}bool check(TimeNode l, TimeNode r) { int tot = 0; for (int i = 1; i &lt;= n; ++i) { if (checkPer(i, l, r))++tot; } return (tot &gt;= n - 1 &amp;&amp; tot &gt;= 2);}bool checkLen(TimeNode l, TimeNode r) { if (r.year - l.year &gt;= 2)return 1; r.month += (r.year - l.year) * 12; if (r.month - l.month &gt;= 2)return 1; r.day += (r.month - l.month) * 30; if (r.day - l.day &gt;= 2)return 1; r.hour += (r.day - l.day) * 24; if (r.hour - l.hour &gt;= 2)return 1; r.minute += (r.hour - l.hour) * 60; r.second += (r.minute - l.minute) * 60; if (r.second - l.second &gt;= 3600)return 1; return 0;}int main() { ios::sync_with_stdio(0); TimeNode Begin(1800, 1, 1, 0, 0, 0), End(2200, 1, 1, 0, 0, 0); int _; cin &gt;&gt; _; for (int sce = 1; sce &lt;= _; ++sce) { cin &gt;&gt; n; clr(n); s.insert(Begin); s.insert(End); for (int i = 1; i &lt;= n; ++i) { int m; cin &gt;&gt; m; for (int j = 1; j &lt;= m; ++j) { int a[10], b[10]; for (int k = 0; k &lt; 6; ++k)cin &gt;&gt; a[k]; for (int k = 0; k &lt; 6; ++k)cin &gt;&gt; b[k]; string str; //没用 getline(cin, str); TimeNode l(a), r(b); A[i].push_back(make_pair(l, r)); s.insert(l); s.insert(r); } } for (set&lt;TimeNode&gt;::iterator it = s.begin(); it != s.end(); ++it) { Node.push_back(*it); } int l = 0, r = 0, cnt = Node.size(); cout &lt;&lt; \"Scenario #\" &lt;&lt; sce &lt;&lt; \":\\n\"; while (l &lt; cnt &amp;&amp; r &lt; cnt) { if (r &gt;= cnt) break; while (r &lt; cnt - 1 &amp;&amp; check(Node[r], Node[r + 1]))++r; if (checkLen(Node[l], Node[r]))Ans.push_back(make_pair(Node[l], Node[r])); l = r + 1; while (l &lt; cnt - 1 &amp;&amp; !check(Node[l], Node[l + 1]))++l; r = l; } if (Ans.size() == 0)cout &lt;&lt; \"no appointment possible\\n\"; else { for (int i = 0; i &lt; Ans.size(); ++i) { cout &lt;&lt; \"appointment possible from \"; Ans[i].first.Output(); cout &lt;&lt; \" to \"; Ans[i].second.Output(); cout &lt;&lt; '\\n'; } } cout &lt;&lt; endl; } return 0;}","link":"/2020/05/07/程设Week10-作业-模拟/"},{"title":"程设Week12-作业","text":"dp令人头秃 A - 必做题 - 1题目描述给出n个数，zjm想找出出现至少(n+1)/2次的数， 现在需要你帮忙找出这个数是多少？ 题目分析 至少出现(n+1)/2次——中位数 排序，取（n+1）/2位置的数输出即可 代码12345678910111213141516#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int ans;int a[1999999];int main(){ int n; while(cin&gt;&gt;n){ for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } sort(a+1,a+n+1); cout&lt;&lt;a[(n+1)/2]&lt;&lt;\"\\n\"; }} B - 必做题 - 2题目描述zjm被困在一个三维的空间中,现在要寻找最短路径逃生！空间由立方体单位构成。zjm每次向上下前后左右移动一个单位需要一分钟，且zjm不能对角线移动。空间的四周封闭。zjm的目标是走到空间的出口。是否存在逃出生天的可能性？如果存在，则需要多少时间？ 题目分析 注意是立体的六个方向，上下左右前后 宽度优先遍历即可，注意记录步数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;int zx[6]={0,0,1,-1,0,0};int zy[6]={1,-1,0,0,0,0};int zz[6]={0,0,0,0,1,-1};bool t[40][40][40];bool v[40][40][40];struct coord{ int x,y,z; int step; coord(int x,int y,int z,int s):x(x),y(y),z(z),step(s){} coord(){step=0;}}s,e;int L,R,C;void solve(){ queue&lt;coord&gt; q; q.push(s); while(q.size()){ coord h(q.front()); q.pop(); for(int i = 0;i&lt;6;i++){ if(0 &lt; h.x + zx[i] &amp;&amp; h.x + zx[i] &lt;= L &amp;&amp; 0 &lt; h.y + zy[i] &amp;&amp; h.y + zy[i] &lt;= R &amp;&amp; 0 &lt; h.z + zz[i] &amp;&amp; h.z + zz[i] &lt;= C &amp;&amp; t[h.x + zx[i]][h.y + zy[i]][h.z + zz[i]] &amp;&amp; !v[h.x + zx[i]][h.y + zy[i]][h.z + zz[i]]){ if(h.x + zx[i] == e.x &amp;&amp; h.y + zy[i] == e.y &amp;&amp; h.z + zz[i] == e.z){ cout&lt;&lt;\"Escaped in \"&lt;&lt;h.step+1&lt;&lt;\" minute(s).\\n\"; return; } v[h.x + zx[i]][h.y + zy[i]][h.z + zz[i]] = 1; q.push(coord(h.x + zx[i],h.y + zy[i],h.z + zz[i],h.step+1)); } } } cout&lt;&lt;\"Trapped!\\n\";}int main(){ while(cin&gt;&gt;L&gt;&gt;R&gt;&gt;C){ if(L==R &amp;&amp; R == C&amp;&amp;C == 0)break; for(int i = 1;i&lt;=L;i++){ for(int j = 1;j&lt;=R;j++){ string str; cin&gt;&gt;str; for(int k = 1;k&lt;=C;k++){ t[i][j][k] = (str[k-1] == '.' ? 1:0); if(str[k-1] == 'S') {s.x = i, s.y = j, s.z = k;t[i][j][k] = 1;} else if(str[k-1] == 'E') {e.x = i, e.y = j, e.z = k;t[i][j][k] = 1;} // cout&lt;&lt;t[i][j][k]; } // cout&lt;&lt;\"\\n\"; } } solve(); for(int i = 1;i&lt;=L;i++){ for(int j = 1;j&lt;=R;j++){ for(int k = 1;k&lt;=C;k++){ t[i][j][k] = v[i][j][k] = 0; } } } } return 0;} C - 必做题 - 3题目描述东东每个学期都会去寝室接受扫楼的任务，并清点每个寝室的人数。每个寝室里面有ai个人(1&lt;=i&lt;=n)。从第i到第j个宿舍一共有sum(i,j)=a[i]+…+a[j]个人这让宿管阿姨非常开心，并且让东东扫楼m次，每一次数第i到第j个宿舍sum(i,j)问题是要找到sum(i1, j1) + … + sum(im,jm)的最大值。且ix &lt;= iy &lt;=jx和ix &lt;= jy &lt;=jx的情况是不被允许的。也就是说m段都不能相交。注：1 ≤ i ≤ n ≤ 1e6 , -32768 ≤ ai ≤ 32767 人数可以为负数。。。。(1&lt;=n&lt;=1000000) 输入输入m，输入n。后面跟着输入n个ai 处理到 EOF 输出输出最大和 题目分析 先考虑了贪心做法：划分负数和正数段，判断m与正数段的关系；然而m&lt;正数段总个数时，无法判定是通过添加负数段使得相邻的正数段连起来or取最大的m个正数段。 然后考虑dp：定义状态dp[i][j][0/1]为：到第i个班级，分成j段，选/不选第i个的最大值。 转移方程： 当前不选 -&gt;前一个选/不选 dp[i][j][0] = max( dp[i-1][j][0],dp[i-1][j][1]) ); 当前选 -&gt;开新段（前面选/不选）/ 合并到前一段 dp[i][j][1] = max(dp[i-1][j-1][1], dp[i-1][j-1][0] ,dp[i-1][j][1]) +a[i]); 后两维用滚动数组就只有2*2大小。然而并不对。原因是：仅凭左边一个无法确定当前状态。 因为当前状态的确定依赖于j-1段的所有状态，所以重新定义dp[i][j]为：到第i个班级，分成j段，同时选第i个的最大值。 新的转移方程： 开新段（从i之前位置的j-1段挑最大的）/ 合并到前一段 dp[i][j] = max( max(dp[k][j-1])(0&lt;k&lt;i) , dp[i-1][j-1]) + a[i]; 发现每次都是从j-1状态转来，那么可以直接抹去这个维度。每次都要计算位置i之前最大的，那可以直接开个变量每次更新最大值，增加一个pre数组记录每个位置之前的最大值，更新下一段的时候用。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define inf 0x7fffffusing namespace std;int m,n,a[1000100];int dp[1000100];int pre[1000100];ll read(){ bool flag = 0; ll ans = 0; char c = getchar(); while(!isdigit(c)) {if(c == '-') flag = 1;c=getchar();} while(isdigit(c)) { ans = ans*10 + (c-'0'); c = getchar(); } return ans*(flag ? -1 :1);}int main(){ while(scanf(\"%d %d\",&amp;m,&amp;n)!=-1){ for(int i = 1;i&lt;=n;i++){ // a[i] = read(); scanf(\"%d\",&amp;a[i]); dp[i] = pre[i] = 0; } int maxx; for(int j = 1;j&lt;=m;j++){ maxx = -inf; for(int i = j;i&lt;=n;i++){ dp[i] = max(pre[i-1],dp[i-1])+a[i]; pre[i-1] = maxx; maxx = max(maxx,dp[i]); } } printf(\"%d\\n\",maxx); } return 0;} D - 选做题 - 1题目描述给出一组括号序列，算出最长匹配的子序列的长度 题目分析 区间dp，注意要左端点要反向遍历，否则无法使用之前更新好的状态。 转移方程：dp[i][j] = max(dp[i][j] , dp[i][k],dp[k+1][j]); if(s[i] matches s[j]) dp[i][j] = dp[i+1][j-1]+2 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int dp[1000][1000];int main(){ string s ; while(cin&gt;&gt;s){ if(s[0] == 'e') break; int n = s.length(); memset(dp,0,sizeof(dp)); // for(int k = 0 ;k &lt; n;k++) dp[k][k] = 1; for(int i = n-1 ;i &gt;= 0;i--){ // 注意反向 for(int j = i+1; j &lt; n;j++){ if((s[i] == '[' &amp;&amp; s[j] == ']') || (s[i] == '(' &amp;&amp; s[j] == ')')) dp[i][j] = dp[i+1][j-1]+2; for(int k = i ; k &lt;= j;k++){ dp[i][j] = max(dp[i][j] , dp[i][k]+dp[k+1][j]); } } } cout&lt;&lt;dp[0][n-1]&lt;&lt;\"\\n\"; } return 0;} E - 选做题 - 2题目描述马上假期就要结束了，zjm还有 n 个作业，完成某个作业需要一定的时间，而且每个作业有一个截止时间，若超过截止时间，一天就要扣一分。zjm想知道如何安排做作业，使得扣的分数最少。Tips: 如果开始做某个作业，就必须把这个作业做完了，才能做下一个作业。 输入有多组测试数据。第一行一个整数表示测试数据的组数第一行一个整数 n(1&lt;=n&lt;=15)接下来n行，每行一个字符串(长度不超过100) S 表示任务的名称和两个整数 D 和 C，分别表示任务的截止时间和完成任务需要的天数。这 n 个任务是按照字符串的字典序从小到大给出。 输出每组测试数据，输出最少扣的分数，并输出完成作业的方案，如果有多个方案，输出字典序最小的一个。 题目分析 观察到作业数量很少，因此可以考虑状压dp 由于题目要求按照字符串从小到大给出结果，因此我们选择将所有课程先按字典序排序。 然后考虑将作业状压：完成置1，未完成置0，转移方程： dp[ i ] = dp[ i-bit[j] ] + max( sum - task[j].ddl , 0 ) ; 其中i表示某个状态，j表示作业号，bit[j]是该作业号对应的位，sum是状态i消耗的总时间，task[j].ddl是任务j的ddl，先然超前完成不可能扣分，因此和0取个max。 整个方程的意思就是：当前状态是由所有和当前状态差一个作业的状态转移而来。 期间还要输出顺序，pre数组直接记录某个状态要完成的最后一个作业号就好。递归输出 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include &lt;bitset&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct rec{ int ddl,c; string name; // void init(int d,int c,string name):ddl(d),c(c),name(name){}}task[20];int n;int bit[20],pre[700000];int dp[700000];bool cmp(const rec &amp;a,const rec &amp;b){ return a.name &lt; b.name;}void getPre(int x){ if(x != 0){ // cout&lt;&lt;bitset&lt;sizeof(int)*8&gt;(x)&lt;&lt;\" \"&lt;&lt;pre[x]&lt;&lt;\"\\n\"; getPre(x-bit[pre[x]]); cout&lt;&lt;task[pre[x]].name&lt;&lt;\"\\n\"; }else return;}int main(){ int T; cin&gt;&gt;T; bit[0] = 1; for(int i = 1;i&lt;=15;i++){ bit[i] = bit[i-1] &lt;&lt; 1; } while(T--){ cin&gt;&gt;n; memset(dp,63,sizeof(dp)); dp[0] = 0; for(int i = 0;i&lt;n;i++){ cin&gt;&gt;task[i].name&gt;&gt;task[i].ddl&gt;&gt;task[i].c; dp[1&lt;&lt;i] = max(task[i].c - task[i].ddl,0) ; } sort(task,task+n,cmp); for(int i = 1;i &lt;= (1&lt;&lt;n)-1;i++){ int sum = 0; for(int j = 0;j&lt;n;j++){ if(bit[j] &amp; i) sum += task[j].c; } // cout&lt;&lt;bitset&lt;sizeof(int)*8&gt;(i)&lt;&lt;\" \"&lt;&lt;sum&lt;&lt;\"\\n\"; for(int j = 0;j&lt;n;j++){ if(bit[j] &amp; i){ // dp[i] = min(dp[i],dp[i-bit[j]] + max( sum + task[j].c-task[j].ddl, 0)); if(dp[i] &gt;= dp[i-bit[j]] + max( sum - task[j].ddl , 0)){ dp[i] = dp[i-bit[j]] + max( sum - task[j].ddl , 0); pre[i] = j; } } } } cout&lt;&lt;dp[(1&lt;&lt;n)-1]&lt;&lt;\"\\n\"; getPre((1&lt;&lt;n)-1); } }","link":"/2020/05/15/程设Week12-作业/"},{"title":"程设Week16-月模拟题","text":"炉石传说最后俩模拟！！ 题目描述 玩家会控制一些角色，每个角色有自己的生命值和攻击力。当生命值小于等于 0 时，该角色死亡。角色分为英雄和随从。 * 玩家各控制一个英雄，游戏开始时，英雄的生命值为 30，攻击力为 0。当英雄死亡时，游戏结束，英雄未死亡的一方获胜。 * 玩家可在游戏过程中召唤随从。棋盘上每方都有 7 个可用于放置随从的空位，从左到右一字排开，被称为战场。当随从死亡时，它将被从战场上移除。 * 游戏开始后，两位玩家轮流进行操作，每个玩家的连续一组操作称为一个回合。 * 每个回合中，当前玩家可进行零个或者多个以下操作： 1) 召唤随从：玩家召唤一个随从进入战场，随从具有指定的生命值和攻击力。 2) 随从攻击：玩家控制自己的某个随从攻击对手的英雄或者某个随从。 3) 结束回合：玩家声明自己的当前回合结束，游戏将进入对手的回合。该操作一定是一个回合的最后一个操作。 * 当随从攻击时，攻击方和被攻击方会同时对彼此造成等同于自己攻击力的伤害。受到伤害的角色的生命值将会减少，数值等同于受到的伤害。例如，随从 X 的生命值为 HX、攻击力为 *AX，随从 *Y 的生命值为 HY、攻击力为 *AY，如果随从 *X 攻击随从 Y，则攻击发生后随从 X 的生命值变为 HX - AY*，随从 *Y 的生命值变为 HY - AX。攻击发生后，角色的生命值可以为负数。 本题将给出一个游戏的过程，要求编写程序模拟该游戏过程并输出最后的局面。 输入 输入第一行是一个整数 n，表示操作的个数。接下来 n 行，每行描述一个操作，格式如下： … 其中表示操作类型，是一个字符串，共有 3 种：summon表示召唤随从，attack表示随从攻击，end表示结束回合。这 3 种操作的具体格式如下： * summon ：当前玩家在位置召唤一个生命值为、攻击力为的随从。其中是一个 1 到 7 的整数，表示召唤的随从出现在战场上的位置，原来该位置及右边的随从都将顺次向右移动一位。 * attack ：当前玩家的角色攻击对方的角色 。是 1 到 7 的整数，表示发起攻击的本方随从编号，是 0 到 7 的整数，表示被攻击的对方角色，0 表示攻击对方英雄，1 到 7 表示攻击对方随从的编号。 * end：当前玩家结束本回合。 注意：随从的编号会随着游戏的进程发生变化，当召唤一个随从时，玩家指定召唤该随从放入战场的位置，此时，原来该位置及右边的所有随从编号都会增加 1。而当一个随从死亡时，它右边的所有随从编号都会减少 1。任意时刻，战场上的随从总是从1开始连续编号。 输出 输出共 5 行。 第 1 行包含一个整数，表示这 n 次操作后（以下称为 T 时刻）游戏的胜负结果，1 表示先手玩家获胜，-1 表示后手玩家获胜，0 表示游戏尚未结束，还没有人获胜。 第 2 行包含一个整数，表示 T 时刻先手玩家的英雄的生命值。 第 3 行包含若干个整数，第一个整数 p 表示 T 时刻先手玩家在战场上存活的随从个数，之后 p 个整数，分别表示这些随从在 T 时刻的生命值（按照从左往右的顺序）。 第 4 行和第 5 行与第 2 行和第 3 行类似，只是将玩家从先手玩家换为后手玩家。 题目分析 用vector模拟插入删除操作 注意插入随从时原有位置的右边会统一右移，有随从死亡时会该随从右边的随从全部左移。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;struct Warrior { int health; int attack; Warrior(int h, int a) : health(h), attack(a) {}};vector&lt;Warrior&gt; player[2];int main() { int N; cin &gt;&gt; N; int pid = 0; player[0].push_back(Warrior(30, 0)); player[1].push_back(Warrior(30, 0)); for(int n=0; n&lt;N; n++) { string type; cin &gt;&gt; type; if(type == \"summon\") { int pos, h, a; cin &gt;&gt; pos &gt;&gt; a &gt;&gt; h; player[pid].insert(player[pid].begin()+pos, Warrior(h, a)); } else if(type == \"attack\") { int att, deff; cin &gt;&gt; att &gt;&gt; deff; player[pid][att].health -= player[!pid][deff].attack; player[!pid][deff].health -= player[pid][att].attack; if(player[pid][att].health &lt;= 0 &amp;&amp; att!=0) { player[pid].erase(player[pid].begin()+att); } if(player[!pid][deff].health &lt;= 0 &amp;&amp; deff!=0) { player[!pid].erase(player[!pid].begin()+deff); } } else if(type == \"end\") { pid = !pid; } } if(player[0][0].health&gt;0 &amp;&amp; player[1][0].health&gt;0) cout &lt;&lt; 0 &lt;&lt; endl; else if(player[0][0].health&gt;0) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; for(int i=0; i&lt;2; i++) { cout &lt;&lt; player[i][0].health &lt;&lt; endl; cout &lt;&lt; player[i].size()-1 &lt;&lt; \" \"; for(int j=1; j&lt;player[i].size(); j++) { cout &lt;&lt; player[i][j].health &lt;&lt; \" \"; } cout &lt;&lt; endl; }} 元素选择器 题目描述 题目分析 注意亿点点细节： 标签大小写不敏感 id属性大小写敏感 空格数不固定 需要split手动通过空格分割选择器 倒着查询比较效率高 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;using namespace std;struct tree{ int id, dots; string tag, name; tree* parent; tree(int id, int dots, string tag, string name): id(id), dots(dots), tag(tag), name(name) ,parent(0) {}};void split(const string &amp;str, vector&lt;string&gt; &amp;out){ string last; last.clear(); for (int i = 0; i &lt; str.size(); i++) { if(str[i] == ' ') { out.push_back(last); last.clear(); } else last+=str[i]; } out.push_back(last);}bool enval(const string &amp;a,const string &amp;b){ if(a.size() != b.size()) return 0; for(int i = 0; i &lt; a.size(); i++) { if(tolower(a[i]) != tolower(b[i])) return 0; } return 1;}bool apply(string str, tree *t){ if(str[0] == '#') return str == t-&gt;name; else return enval(str, t-&gt;tag);}int main(){ int n,m; string line; scanf(\"%d%d\",&amp;n,&amp;m); getline(cin,line); vector&lt;tree *&gt; nodes; stack&lt;tree *&gt; sta; for(int i = 1; i &lt;= n; i++) { getline(cin, line); int dots=0; while (line[dots] == '.') dots++; string tag, name; stringstream ss(line.substr(dots)); ss &gt;&gt; tag &gt;&gt; name; tree *now = new tree(i, dots, tag, name); if(!sta.empty()) { tree* top; while (top = sta.top(), top-&gt;dots &gt;= dots) sta.pop(); now-&gt;parent = top; } sta.push(now); nodes.push_back(now); } vector&lt;string&gt; selector; vector&lt;int&gt; ans; ans.clear(); while (m--) { getline(cin, line); selector.clear(); split(line, selector); ans.clear(); for (int i = 0; i &lt; nodes.size(); i++) { if (apply(selector.back(),nodes[i])) { tree *t = nodes[i]; int sl = selector.size()-1; while(t &amp;&amp; sl&gt;=0) { if(apply(selector[sl],t)) sl--; t = t-&gt;parent; } if (sl == -1) ans.push_back(nodes[i]-&gt;id); } } printf(\"%d \",ans.size()); for (int i = 0; i &lt; ans.size() ; i++) printf(\"%d \",ans[i]); printf(\"\\n\"); } return 0;}","link":"/2020/06/10/程设Week-16-月模拟题/"},{"title":"程设Week16-模拟","text":"T1忘记longlong，难受 TT数鸭子题目描述这一天，TT因为疫情在家憋得难受，在云吸猫一小时后，TT决定去附近自家的山头游玩。 TT来到一个小湖边，看到了许多在湖边嬉戏的鸭子，TT顿生羡慕。此时他发现每一只鸭子都不 一样，或羽毛不同，或性格不同。TT在脑子里开了一个map&lt;鸭子，整数&gt; tong，把鸭子变成了 一些数字。现在他好奇，有多少只鸭子映射成的数的数位中不同的数字个数小于k。 输入输入第一行包含两个数n,k，表示鸭子的个数和题目要求的k。 接下来一行有n个数,$a_i$，每个数表示鸭子被TT映射之后的值。 输出输出一行，一个数，表示满足题目描述的鸭子的个数。 无行末空格 $a_i &lt; =10^{15}$！！！ 题目分析 按位拆分判断就星，观察到k&gt;=10的情况存在，就不用判断了，直接输出数个数就星 用long long /wx 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#include &lt;map&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#define ll long long#define INF 0x3f3f3f3fusing namespace std;ll read(){ ll x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}bool v[10];int main(){ int n = read(),k=read(),tot = 0 ; if(k &gt; 10) cout&lt;&lt;n; else { for(int i = 1;i&lt;=n;i++){ long long num = read(),cnt = 0; memset(v,0,sizeof(v)); while(num){ int lb = num%10; num /= 10; if(!v[lb]) { v[lb] = 1;cnt++; } if(cnt &gt;= k) break; } if(cnt &lt; k) tot++; } cout&lt;&lt;tot; } return 0;} ZJM要抵御宇宙射线题目描述据传，2020年是宇宙射线集中爆发的一年，这和神秘的宇宙狗脱不了干系！但是瑞神和东东忙 于正面对决宇宙狗，宇宙射线的抵御工作就落到了ZJM的身上。假设宇宙射线的发射点位于一个 平面，ZJM已经通过特殊手段获取了所有宇宙射线的发射点，他们的坐标都是整数。而ZJM要构 造一个保护罩，这个保护罩是一个圆形，中心位于一个宇宙射线的发射点上。同时，因为大部分 经费都拨给了瑞神，所以ZJM要节省经费，做一个最小面积的保护罩。当ZJM决定好之后，东东 来找ZJM一起对抗宇宙狗去了，所以ZJM把问题扔给了你~ 输入输入 第一行一个正整数N，表示宇宙射线发射点的个数 接下来N行，每行两个整数X,Y，表示宇宙射线发射点的位置 输出输出包括两行 第一行输出保护罩的中心坐标x,y 用空格隔开 第二行输出保护罩半径的平方 （所有输出保留两位小数，如有多解，输出x较小的点，如扔有多解，输入y较小的点）无行末空格 题目分析 观察到n&lt;=1000，所以直接n^2枚举所有点之间的距离，答案就是每个点距离其他点最大值（要全部覆盖到）的最小值（最小面积） 坑点： 最后输出的是半径的平方 “如有多解，输出x较小的点，如扔有多解，输入y较小的点” 要求排序后再枚举 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;cfloat&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#include &lt;map&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#define ll long long#define INF 0x3f3f3f3fusing namespace std;ll read(){ ll x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}struct node{ double x,y;}nd[2000];double dis = LDBL_MAX;int ans;inline double getDis(int i,int j){ return (nd[i].x-nd[j].x)*(nd[i].x-nd[j].x) + (nd[i].y-nd[j].y)*(nd[i].y-nd[j].y);}bool cmp(node &amp;a,node &amp;b){ if (a.x == b.x){ return a.y &lt; b.y; }else return a.x &lt; b.x;}int main(){ int n =read(); for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;nd[i].x&gt;&gt;nd[i].y; } sort(nd+1,nd+n+1,cmp); for(int i = 1;i&lt;=n;i++){ double diss = 0.0; for(int j = 1;j&lt;=n;j++){ if(i != j){ diss = max(diss,getDis(i,j)); } } if(dis &gt; diss){ dis = diss; ans = i; } } printf(\"%.2lf %.2lf\\n%.2lf\",nd[ans].x,nd[ans].y,dis); return 0;} 宇宙狗的危机题目描述在瑞神大战宇宙射线中我们了解到了宇宙狗的厉害之处，虽然宇宙狗凶神恶煞，但是宇宙狗有一 个很可爱的女朋友。 最近，他的女朋友得到了一些数，同时，她还很喜欢树，所以她打算把得到的数拼成一颗树。 这一天，她快拼完了，同时她和好友相约假期出去玩。贪吃的宇宙狗不小心把树的树枝都吃掉 了。所以恐惧包围了宇宙狗，他现在要恢复整棵树，但是它只知道这棵树是一颗二叉搜索树，同 时任意树边相连的两个节点的gcd(greatest common divisor)都超过1。 但是宇宙狗只会发射宇宙射线，他来请求你的帮助，问你能否帮他解决这个问题。 输入输入第一行一个t，表示数据组数。 对于每组数据，第一行输入一个n，表示数的个数 接下来一行有n个数$a_i$，输入保证是升序的。 输出每组数据输出一行，如果能够造出来满足题目描述的树，输出Yes，否则输出No。 无行末空格。 数据范围n&lt;=700 题目分析 首先判断gcd预处理出可以连接在一起的数字 dp[i][j]表示区间[i,j]是否可行 对于某段区间[i,j]，枚举k，判断 k与j+1可以连接，那么区间[i,j+1]可行 k与i-1可以连接，那么区间[i-1,j]可行 因为是二叉搜索树，所以应该区分左右子树 若区间[i,j]可以转移到[i,j+1]显然[i,j]是j+1的左子树 若区间[i,j]可以转移到[i-1,j]显然[i,j]是i-1的右子树 那么状态应该改为dp[i][j][0/1]0表示左子树1表示右子树 btw，区间[i,j]可以通过k向左右转移的条件是：dp[i][k][0]&amp;&amp;dp[k][j][1] 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#include &lt;map&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#define ll long long#define INF 0x3f3f3f3fusing namespace std;ll read(){ ll x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}int a[750];bool p[750][750];bool dp[750][750][2];int gcd(int a,int b){return b == 0 ? a : gcd(b,a%b);}int main(){ int t = read(); while(t--){ memset(a,0,sizeof(a)); memset(p,0,sizeof(p)); memset(dp,0,sizeof(dp)); int n = read(); for(int i = 1;i&lt;=n;i++){ a[i] = read(); dp[i][i][0] = dp[i][i][1] = 1; } for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=n;j++){ if(i!=j) p[i][j] = gcd(a[i],a[j]) &gt; 1; } } bool flag = 0 ; for(int l = 1;l &lt;= n;l++){ for(int i = 1;i+l-1&lt;=n;i++){ int j = i+l-1; for(int k = i; k&lt;=j ;k++){ if(dp[i][k][0] &amp;&amp; dp[k][j][1]){ if(i == 1 &amp;&amp; j == n) flag = 1; if(p[k][j+1]) dp[i][j+1][0] = 1; if(p[i-1][k]) dp[i-1][j][1] = 1; } } } } if(flag)cout&lt;&lt;\"Yes\\n\"; else cout&lt;&lt;\"No\\n\"; }}","link":"/2020/06/10/程设Week16-模拟/"},{"title":"程设Week2 实验","text":"本周三道大模拟 超时10min写完 T1 Gym 270437A题目描述 假设如上图，这个烷烃基有6个原子和5个化学键，6个原子分别标号1~6，然后用一对数字 a,b 表示原子a和原子b间有一个化学键。这样通过5行a,b可以描述一个烷烃基 你的任务是甄别烷烃基的类别。 原子没有编号方法，比如1 22 33 44 55 6和1 32 32 44 55 6是同一种，本质上就是一条链，编号其实是没有关系的 题目分析 首先观察输入，是一个图。 再找出判断五种烷烃的区别，可以发现n-hexane、2,2-dimethylbutane分别最多只有2度、4度节点；其他三种都是最多3度节点，但是2,3-dimethylbutane有两个3度节点； 剩下两个不太容易判断。考虑从其3度节点跑dfs找deep，2-methylpentance的deep为4，2-methylpentance的deep为3. 因为是戊烷所以不用考虑太多复杂度。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int to[10],nex[10],head[10],p,di[10],vis[10];void add(int a,int b){ p++; to[p] = b; // 一开始写成a了 真的拉跨 nex[p] = head[a]; head[a] = p;}int dfs(int i,int dep){ int maxx = 0; vis[i]=1; for(int e = head[i];e;e=nex[e]){ if(!vis[to[e]]){ maxx = max(maxx,dfs(to[e],dep+1)); } } return (maxx == 0) ? dep : maxx;}int main(){ int T; cin&gt;&gt;T; while(T--){ p=0; for(int i=0;i&lt;10;i++){ to[i] = nex[i] = head[i] = di[i] = vis[i] =0; } for(int i =1;i&lt;=5;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b); add(b,a); di[a]++;// 记录度数 di[b]++; } int maxx = 0; for(int i =1;i&lt;=6;i++){ maxx = max(di[i],maxx); } if(maxx == 4){ cout&lt;&lt;\"2,2-dimethylbutane\\n\"; }else if(maxx == 2){ cout&lt;&lt;\"n-hexane\\n\"; }else{ int dep = 1; int cont = 0; for(int i =1;i&lt;=6;i++){ if(di[i] == 3){ cont++; dep = dfs(i,dep); } } // cout&lt;&lt;dep&lt;&lt;\"\\n\"; if(cont == 2){ cout&lt;&lt;\"2,3-dimethylbutane\\n\"; }else if(dep == 3){ cout&lt;&lt;\"3-methylpentane\\n\"; }else{ cout&lt;&lt;\"2-methylpentane\\n\"; } } }} 反思其实一开始从度数入手找特征是没有问题的，只是第二个和第三个很遗憾没找出来，选用dfs最后调了半天（有这时间T3早A了） 第二个和第三个的特征为：三度节点连接的节点的度数和不同，分别为4/5. 多思考 代码少 T2 HDU 2093题目描述某次考试一共八道题（A,B,C,D,E,F,G,H），每个人做的题都在对应的题号下有个数量标记，负数表示该学生在该题上有过的错误提交次数但到现在还没有AC，正数表示AC所耗的时间，如果正数a跟上了一对括号，里面有个正数b,则表示该学生AC了这道题，耗去了时间a，同时曾经错误提交了b次。例子可见下方的样例输入与输出部分。 题目分析 $ 总时间 = 罚时 + 实际总时长 = 单位罚时\\times错误提交次数 + 实际总时长$ 第一关键字：通过题数、第二关键字：总时间 某道题上是负数说明最终也未通过，就算通过也可能会跟上“（负数）”表示有错误提交需要加罚时。 ticks： 读入时使用$stoi()$函数进行str2int的转换 输出时使用 123cout.width(10);cout.setf(ios::left);cout.unsetf(ios::left); ​ 进行宽度控制 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int maxx = 2e5;struct rec{ string name; int score; int ac;}names[maxx];bool cmp(rec a,rec b){ if(a.ac == b.ac){ return a.score&lt;b.score; }else{ return a.ac&gt;b.ac; }}int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; string s; int cnt = 0; while(cin&gt;&gt;s){ names[cnt].name = s; for(int i =1;i&lt;=n;i++){ cin&gt;&gt;s; string::size_type sz; int score = stoi(s,&amp;sz); //sz为原字符串中int结束的位置 后边可以切割用 if(score &gt; 0){ names[cnt].ac++; names[cnt].score += score; if(s[s.length()-1] == ')'){ int fashi = stoi(s.substr(sz+1)); names[cnt].score += fashi*m; } } } cnt++; } sort(names,names+cnt,cmp); for(int i = 0;i&lt;cnt;i++){ cout.width(10); cout.setf(ios::left); cout&lt;&lt;names[i].name&lt;&lt;\" \"; cout.width(2); cout.unsetf(ios::left); cout&lt;&lt;names[i].ac&lt;&lt;\" \"; cout.width(4); cout&lt;&lt;names[i].score&lt;&lt;\"\\n\"; } } T3 POJ 1786题目描述​ 牌局由四个人构成，围成一圈。我们称四个方向为北 东 南 西。对应的英文是North，East，South，West。游戏一共由一副扑克，也就是52张构成。开始，我们指定一位发牌员（东南西北中的一个，用英文首字母标识）开始发牌，发牌顺序为顺时针，发牌员第一个不发自己，而是发他的下一个人（顺时针的下一个人）。这样，每个人都会拿到13张牌。现在我们定义牌的顺序，首先，花色是（梅花）&lt;（方片）&lt;（黑桃）&lt;（红桃），（输入时，我们用C,D,S,H分别表示梅花，方片，黑桃，红桃，即其单词首字母）。对于牌面的值，我们规定2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; T &lt; J &lt; Q &lt; K &lt; A。现在你作为上帝，你要从小到大排序每个人手中的牌，并按照给定格式输出。（具体格式见输出描述和样例输出）。 输入输入包含多组数据每组数据的第一行包含一个大写字符，表示发牌员是谁。如果该字符为‘#’则表示输入结束。接下来有两行，每行有52个字符，表示了26张牌，两行加起来一共52张牌。每张牌都由两个字符组成，第一个字符表示花色，第二个字符表示数值。 1234NCTCAH8CJD4C6D9SQC7S5HAD2HJH9CKD3H6D6D7H3HQH4C5DKHKS9SJDTS3S7S4C4CQHTSAH2D8DJSTSKS2H5D5DQDAH7C9S8C8S6C2C3# 输出输出多组数据发牌的结果，每组数据之后需要额外多输出一个空行每组数据应该由24行的组成，输出按照顺时针方向，始终先输出South Player的结果，每位玩家先输出一行即玩家名称（东南西北），接下来五行，第一行和第五行输出固定格式（见样例），第二行和第四行按顺序和格式输出数值（见样例），第三行按顺序和格式输出花色（见样例）。 123456789101112131415161718192021222324South player:+---+---+---+---+---+---+---+---+---+---+---+---+---+|6 6|A A|6 6|J J|5 5|6 6|7 7|9 9|4 4|5 5|7 7|9 9|T T|| C | C | D | D | S | S | S | S | H | H | H | H | H ||6 6|A A|6 6|J J|5 5|6 6|7 7|9 9|4 4|5 5|7 7|9 9|T T|+---+---+---+---+---+---+---+---+---+---+---+---+---+West player:+---+---+---+---+---+---+---+---+---+---+---+---+---+|2 2|5 5|9 9|K K|5 5|7 7|9 9|4 4|T T|J J|A A|8 8|A A|| C | C | C | C | D | D | D | S | S | S | S | H | H ||2 2|5 5|9 9|K K|5 5|7 7|9 9|4 4|T T|J J|A A|8 8|A A|+---+---+---+---+---+---+---+---+---+---+---+---+---+North player:+---+---+---+---+---+---+---+---+---+---+---+---+---+|3 3|4 4|J J|2 2|3 3|T T|Q Q|K K|8 8|Q Q|K K|2 2|3 3|| C | C | C | D | D | D | D | D | S | S | S | H | H ||3 3|4 4|J J|2 2|3 3|T T|Q Q|K K|8 8|Q Q|K K|2 2|3 3|+---+---+---+---+---+---+---+---+---+---+---+---+---+East player:+---+---+---+---+---+---+---+---+---+---+---+---+---+|7 7|8 8|T T|Q Q|4 4|8 8|A A|2 2|3 3|6 6|J J|Q Q|K K|| C | C | C | C | D | D | D | S | S | H | H | H | H ||7 7|8 8|T T|Q Q|4 4|8 8|A A|2 2|3 3|6 6|J J|Q Q|K K|+---+---+---+---+---+---+---+---+---+---+---+---+---+ 题目分析 首先用vector&lt;pair&lt;char,char&gt;&gt; player[4] 表示每个玩家摸到牌的数组，pair&lt;char,char&gt;代表牌上的花色和字母。 假设我们不考虑是谁发牌，那么直接两个for把牌依次读取到player数组，然后直接进行双关键字排序即可，因为这两个步骤不涉及输出。 但是我们要考虑发牌的人，因为这关系到输出，因此考虑x发牌的第几个下家是South。我们记这个数为n，那么输出循环中就需要依次输出player[n+i]的序列。这里需要思考一下，确实不太好转过弯来，这时候就可以先输出试一下。 包括规则和玩家代号在内有很多映射，因此我们使用map记录。oj不支持c++11，因此我们只能直接在main函数里给出各种映射，这里可以使用一些小tricks简化代码。 记得加换行！！！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869typedef vector&lt;pair&lt;char,char&gt; &gt; Pyr;Pyr players[4]; string s[4] = {\"South player:\\n\",\"West player:\\n\",\"North player:\\n\",\"East player:\\n\"};string cut = \"+---+---+---+---+---+---+---+---+---+---+---+---+---+\\n\";map&lt;char,int&gt; m;map&lt;char,int&gt; flw;map&lt;char,char&gt; num;bool cmp(pair&lt;char,char&gt; a,pair&lt;char,char&gt; b){ if(flw[a.first] == flw[b.first]){ return num[a.second] &lt; num[b.second]; }else{ return flw[a.first]&lt;flw[b.first]; }}int main(){ char starter; num['T'] = '9'+1; num['J'] = '9'+2; num['Q'] = '9'+3; num['K'] = '9'+4; num['A'] = '9'+5; flw['C'] = 0; flw['D'] = 1; flw['S'] = 2; flw['H'] = 3; m['N'] = 1; m['E'] = 0; m['S'] = 3; m['W'] = 2; for(int i =2;i&lt;=9;i++){ num['0'+i] = '0'+i; } while(cin&gt;&gt;starter){ if(starter == '#')break; for(int i = 1;i&lt;=13;i++){ for(int j=0;j&lt;4;j++){ char a,b; cin&gt;&gt;a&gt;&gt;b; players[j].push_back(make_pair(a,b)); } } for(int i =0;i&lt;4;i++){ sort(players[i].begin(),players[i].end(),cmp); } int cnt = m[starter]; for(int i =0;i&lt;4;i++){ int k = (cnt+i)%4; cout&lt;&lt;s[i]; cout&lt;&lt;cut; for(int i =0;i&lt;13;i++){ cout&lt;&lt;\"|\"&lt;&lt;players[k][i].second&lt;&lt;\" \"&lt;&lt;players[k][i].second&lt;&lt;\"\"; } cout&lt;&lt;\"|\\n\"; for(int i =0;i&lt;13;i++){ cout&lt;&lt;\"| \"&lt;&lt;players[k][i].first&lt;&lt;\" \"; } cout&lt;&lt;\"|\\n\"; for(int i =0;i&lt;13;i++){ cout&lt;&lt;\"|\"&lt;&lt;players[k][i].second&lt;&lt;\" \"&lt;&lt;players[k][i].second&lt;&lt;\"\"; } cout&lt;&lt;\"|\\n\"; cout&lt;&lt;cut; }cout&lt;&lt;\"\\n\"; for(int i =0;i&lt;4;i++){ players[i].clear(); } } return 0;}","link":"/2020/03/01/程设Week2-实验/"},{"title":"程设Week5-作业","text":"本周线性数据结构专题 A - 最大矩形题目描述给一个直方图，求直方图中的最大矩形的面积。例如，下面这个图片中直方图的高度从左到右分别是2, 1, 4, 5, 1, 3, 3, 他们的宽都是1，其中最大的矩形是阴影部分。 输入输入包含多组数据。每组数据用一个整数n来表示直方图中小矩形的个数，你可以假定1 &lt;= n &lt;= 100000. 然后接下来n个整数h1, …, hn, 满足 0 &lt;= hi &lt;= 1000000000. 这些数字表示直方图中从左到右每个小矩形的高度，每个小矩形的宽度为1。 测试数据以0结尾。 输出对于每组测试数据输出一行一个整数表示答案。 题目分析 对于某一列，以其位高构成的最大矩形的左右两端应当是：向左右两端找到第一个高度小于该列的位置‘ 单调栈可以$O(n)$地解决查找某元素某侧第一个最小值问题； 那么单调栈向左扫一次向右扫一次即可解决 代码123456789101112131415161718192021222324252627282930313233343536373839404142int rigt[200000],lef[200000];struct rec{ long long data; int pos;}k[200000];int main(){ int n; while(cin&gt;&gt;n){ if(n == 0)break; stack&lt;rec&gt; s; for(int i = 0;i&lt;n;i++){ cin&gt;&gt;k[i].data; k[i].pos = i; while(!s.empty()&amp;&amp;s.top().data&gt;k[i].data){ rigt[s.top().pos] = i; s.pop(); } s.push(k[i]); } while(!s.empty()){ rigt[s.top().pos] = n; s.pop(); } for(int i = n-1;i&gt;=0;i--){ while(!s.empty()&amp;&amp;s.top().data&gt;k[i].data){ lef[s.top().pos] = i; s.pop(); } s.push(k[i]); } while(!s.empty()){ lef[s.top().pos] = -1; s.pop(); } long long ans = 0; for(int i = 0;i&lt;n;i++){ ans = max(ans,k[i].data*(rigt[i]-lef[i]-1)); } cout&lt;&lt;ans&lt;&lt;\"\\n\"; } return 0;} B - TT’s Magic Cat题目描述给定一段序列，要求支持连续区间上的加法，输出操作结束后的序列。 输入长度为n的序列，q次操作 输出q次操作后的序列 题目分析 用差分数组进行预处理，则可以将区间操作转化为单点操作。对[l,r]区间上的加法变为差分数组c上c[l]+和c[r+1]- 差分数组对应的前缀和数组就是最终答案 代码12345678910111213141516171819202122232425long long minu[300000];long long a[300000];int main(){ ios::sync_with_stdio(false); //会卡输入 int n,q; cin&gt;&gt;n&gt;&gt;q; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } for(int i = 1;i&lt;=n;i++){ minu[i] = a[i]-a[i-1]; } for(int j = 1;j&lt;=q;j++){ int l,r,c; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; minu[l] += c; minu[r+1] -= c; } long long ans =0; for(int i = 1;i&lt;=n;i++){ ans += minu[i]; cout&lt;&lt;ans&lt;&lt;\" \"; } return 0;} C - 平衡字符串题目描述一个长度为 n 的字符串 s，其中仅包含 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符。 如果四种字符在字符串中出现次数均为 n/4，则其为一个平衡字符串。 现可以将 s 中连续的一段子串替换成相同长度的只包含那四个字符的任意字符串，使其变为一个平衡字符串，问替换子串的最小长度? 如果 s 已经平衡则输出0。 输入一行字符串 输出一个整数表示答案 题目分析 关键字：连续 考虑尺取方法：对于一个子串s’ 如果替换掉s‘可以形成平衡串，则有可能可以取更短，Left pointer++； 否则应该考虑更长的串，right pointer++ 如何判断取一个子串s’时是否能形成平衡串？ 考虑平衡串的性质： 分别统计串外四种字母的数目，取四者max，再用max减去剩余三个字母的数目，得到要“填充”的字母数 子串长度与上述数比较，如果子串较长，则再用子串长减去要“填充”到外面的字母数，如果余下的数是四的倍数则满足要求。 注意：如果right pointer越界则直接结束（不可能再满足要求） 代码123456789101112131415161718192021222324252627282930313233343536373839int count[5];map&lt;char,int&gt; mp;int main(){ ios::sync_with_stdio(false); string s; cin&gt;&gt;s; mp['Q'] = 0; mp['W'] = 1; mp['E'] = 2; mp['R'] = 3; for(int i = 0;i&lt;s.size();i++){ count[mp[s[i]]]++; } if(count[0] == count[1] &amp;&amp; count[1] == count[2] &amp;&amp; count[2]== count[3]){ cout&lt;&lt;0; }else { int l = -1,r = 0; count[mp[s[r]]]--; int ans = INT32_MAX; while(l != r &amp;&amp; r &lt; s.size()){ int maxx = max(count[0],max(count[1],max(count[2],count[3]))); int tot = 0; for(int i = 0;i&lt;4;i++){ tot += maxx-count[i]; } // cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;\" \"&lt;&lt;tot&lt;&lt;\"\\n\"; if(tot &lt;= (r-l) &amp;&amp; (r-l-tot) %4 == 0){ ans = min(ans,r-l); l++; count[mp[s[l]]]++; }else { r++; count[mp[s[r]]]--; } } cout&lt;&lt;ans; } return 0;} D - 滑动窗口题目描述ZJM 有一个长度为 n 的数列和一个大小为 k 的窗口, 窗口可以在数列上来回移动. 现在 ZJM 想知道在窗口从左往右滑的时候，每次窗口内数的最大值和最小值分别是多少. 例如：数列是 [1 3 -1 -3 5 3 6 7], 其中 k 等于 3. Window position Minimum value Maximum value [1 3 -1] -3 5 3 6 7 -1 3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7 输入输入有两行。第一行两个整数n和k分别表示数列的长度和滑动窗口的大小，1&lt;=k&lt;=n&lt;=1000000。第二行有n个整数表示ZJM的数列。 输出输出有两行。第一行输出滑动窗口在从左到右的每个位置时，滑动窗口中的最小值。第二行是最大值。 题目分析 单调栈是解决整个序列范围内的问题 如果对序列加上区间限制，则需要把”过期“的栈底元素弹出栈，就变成了单调队列 因此单调队列不是严格队列，而是双端队列 具体实现上只要每次入栈（队列）时判断一下当前位置和队首元素位置的差是否大于区间长度。如果大则弹出队首即可。 tips: 最大最小值可以在一个循环里同时维护。 代码12345678910111213141516171819202122232425262728293031323334353637int n,k;long long minx[2000000];long long maxx[2000000];struct rec{ int pos; long long data;};int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;k; deque&lt;rec&gt; q1,q2; for(int i = 1;i &lt;= n;i++){ rec d; cin&gt;&gt;d.data; d.pos = i; if(!q1.empty() &amp;&amp; q1.front().pos &lt;= i-k){ q1.pop_front(); } while(!q1.empty() &amp;&amp; q1.back().data &gt; d.data){ q1.pop_back(); } q1.push_back(d); minx[i] = q1.front().data; if(!q2.empty() &amp;&amp; q2.front().pos &lt;= i-k){ q2.pop_front(); } while(!q2.empty() &amp;&amp; q2.back().data &lt; d.data){ q2.pop_back(); } q2.push_back(d); maxx[i] = q2.front().data; } for(int i = k;i&lt;=n;i++) cout&lt;&lt;minx[i]&lt;&lt;\" \"; cout&lt;&lt;'\\n'; for(int i = k;i&lt;=n;i++) cout&lt;&lt;maxx[i]&lt;&lt;\" \"; return 0;} 总结线性数据结构用于解决某些特定问题时时间复杂度十分优秀，但是寻找思路比较难。","link":"/2020/03/27/程设Week5-作业+周模拟题/"},{"title":"Week6-作业+周模拟题","text":"本周并查集专题 然而A题并不是并查集.jpg A - 氪金带东题目描述给出一棵树，求距离每个点最远的点的距离。 输入输入文件包含多组测试数据。对于每组测试数据，第一行一个整数N (N&lt;=10000)，接下来有N-1行，每一行两个数，对于第i行的两个数，它们表示与i号电脑连接的电脑编号以及它们之间网线的长度。网线的总长度不会超过10^9，每个数之间用一个空格隔开。 输出对于每组测试数据输出N行，第i行表示i号电脑的答案 (1&lt;=i&lt;=N). 题目分析 因为是树所以存在直； 到某个点最远距离的点必然为直径两端点中的一个点； 题目转为：求树上直径两端点，并分别求两端点到所有点的距离； 那么只需要进行三次遍历： 第一次：从任一点开始，找到距离最远的点记为L，L为直径的一个端点； 第二次：从L点开始，找到距离最远的点记为R，R为直径的另一端点，顺便求出L到所有点的距离； 第三次：从R点开始，找到R到所有点的距离。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct Edge{ int from,to,w; Edge(int f,int t,int w):from(f),to(t),w(w){}};vector&lt;Edge&gt; G[10001];bool v[10001];int ld[10001],rd[10001];int n;int bfs(int f,int dis[]){ for(int i = 0;i&lt;=n;i++) {dis[i] = 0;v[i] = 0;} queue&lt;int&gt; q; q.push(f); v[f] = 1; while(!q.empty()){ int h = q.front(); q.pop(); for(auto &amp;e:G[h]){ if(!v[e.to]){ v[e.to] = 1; q.push(e.to); dis[e.to] = dis[h] + e.w; } } } int last = 1; for(int i = 1;i&lt;=n;i++){ if(dis[i] &gt; dis[last]){ last = i; } } return last;}int dfs(int f,int dis[]){ v[f] = 1; int pos = f; for(auto &amp;e:G[f]){ if(!v[e.to]){ dis[e.to] = dis[f] + e.w; int s = dfs(e.to,dis); pos = dis[pos] &gt; dis[s] ? pos : s; } } return pos;}int main(){ while(cin&gt;&gt;n){ for(int i = 1;i&lt;=n;i++) G[i].clear(); for(int v = 2;v&lt;=n;v++){ int u,w; cin&gt;&gt;u&gt;&gt;w; G[u].emplace_back(u,v,w); G[v].emplace_back(v,u,w); } for(int i = 0;i&lt;=n;i++) {rd[i] = 0;v[i] = 0;} int r = dfs(1,rd); for(int i = 0;i&lt;=n;i++) {rd[i] = 0;v[i] = 0;} int l = dfs(r,rd); for(int i = 0;i&lt;=n;i++) {ld[i] = 0;v[i] = 0;} dfs(l,ld); // cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;\"\\n\"; for(int i = 1;i &lt;= n;i++){ // cout&lt;&lt;rd[i]&lt;&lt;\" \"&lt;&lt;ld[i]&lt;&lt;\"\\n\"; cout&lt;&lt;max(rd[i],ld[i])&lt;&lt;\"\\n\"; } } return 0;} B - 戴好口罩题目描述新型冠状病毒肺炎（Corona Virus Disease 2019，COVID-19），简称“新冠肺炎”，是指2019新型冠状病毒感染导致的肺炎。如果一个感染者走入一个群体，那么这个群体需要被隔离！小A同学被确诊为新冠感染，并且没有戴口罩！！！！！！危！！！时间紧迫！！！！需要尽快找到所有和小A同学直接或者间接接触过的同学，将他们隔离，防止更大范围的扩散。众所周知，学生的交际可能是分小团体的，一位学生可能同时参与多个小团体内。请你编写程序解决！戴口罩！！ 输入多组数据，对于每组测试数据：第一行为两个整数n和m（n = m = 0表示输入结束，不需要处理），n是学生的数量，m是学生群体的数量。0 &lt; n &lt;= 3e4 ， 0 &lt;= m &lt;= 5e2学生编号为0~n-1小A编号为0随后，m行，每行有一个整数num即小团体人员数量。随后有num个整数代表这个小团体的学生。 输出输出要隔离的人数，每组数据的答案输出占一行 题目分析 将每个小团体加入同一个并查集，如果多个小团体之间的成员有重合则应该合并为同一个小团体； 最终查找一遍与0号在同一个小团体的人数即可。 代码123456789101112131415161718192021222324252627282930313233343536int father[500000];int find(int x){ return father[x] == x ? x : father[x] = find(father[x]);}void merge(int a,int b){ father[find(a)] = find(b); return ;}int main (){ int n,m; while(cin&gt;&gt;n&gt;&gt;m){ if(n==0&amp;&amp;m==0)break; for(int i = 0;i&lt;=n;i++) father[i] = i; for(int i = 0;i&lt;m;i++){ int k,first,other; cin&gt;&gt;k&gt;&gt;first; for(int j = 1;j &lt; k;j++){ cin&gt;&gt;other; if(find(first) != find(other)){ merge(first,other); } } } int fa = find(0); int ans = 0; for(int i = 0;i&lt;n;i++){ if(find(i) == fa){ ans++; } } cout&lt;&lt;ans&lt;&lt;\"\\n\"; } return 0;} C - 掌握魔法的东东题目描述东东在老家农村无聊，想种田。农田有 n 块，编号从 1~n。种田要灌水众所周知东东是一个魔法师，他可以消耗一定的 MP 在一块田上施展魔法，使得黄河之水天上来。他也可以消耗一定的 MP 在两块田的渠上建立传送门，使得这块田引用那块有水的田的水。 (1&lt;=n&lt;=3e2)黄河之水天上来的消耗是 Wi，i 是农田编号 (1&lt;=Wi&lt;=1e5)建立传送门的消耗是 Pij，i、j 是农田编号 (1&lt;= Pij &lt;=1e5, Pij = Pji, Pii =0)东东为所有的田灌水的最小消耗 输入第1行：一个数n第2行到第n+1行：数wi第n+2行到第2n+1行：矩阵即pij矩阵 输出东东最小消耗的MP值 题目分析 对于每块田，有两种选择：黄河之水天上来；或者从最近的有水的田引水； 枚举一下情况： 一块田$i$黄河之水天上来，剩下的全都直接或间接引水；那么代价就是最小生成树+$w_i$ 两块田$i、j$黄河之水天上来，剩下的全都直接或间接引水；那么就变成了两棵树，每棵树符合上述情况； 以此类推 可以将每个田的“天”和其连一条边，然后和田与田之间的边共同参与最小生成森林的构造，最小生成森林最终应该有n条边； 注意：将两个已经分别连到天的树再连起来是没有意义的，合并的时候应该直接跳过，所以从天上引水的并查集要打上标记。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int maxx = 2e5+10;vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt; edge;int father[maxx];bool v[maxx];int find(int x){ return father[x] == x ? x : father[x] = find(father[x]);}void merge(int a,int b){ int fa = find(a); int fb = find(b); father[fa] = fb; if(v[fa] || v[fb]) v[fa] = v[fb] = 1; return ;}bool cmp(const pair&lt;int,pair&lt;int,int&gt; &gt;&amp; a,const pair&lt;int,pair&lt;int,int&gt; &gt;&amp; b) { return a.first &lt; b.first;}int main(){ int n,w,p; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;w; father[i] = i; father[i+n] = i+n; v[i+n] = 1; edge.push_back(make_pair(w,make_pair(i+n,i))); } for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=n;j++){ cin&gt;&gt;p; if(i&lt;=j)continue; else { edge.push_back(make_pair(p,make_pair(i,j))); } } } sort(edge.begin(),edge.end(),cmp); int cnt = 0 ,ans = 0; for(auto &amp;i:edge){ int u = i.second.first; int t = i.second.second; int w = i.first; int fu = find(u); int ft = find(t); if(!(v[fu]&amp;&amp;v[ft]) &amp;&amp; fu != ft ){ merge(u,t); ans += w; // cout&lt;&lt;u&lt;&lt;\" \"&lt;&lt;t&lt;&lt;\" \"&lt;&lt;w&lt;&lt;\"\\n\"; cnt++; } if(cnt == n)break; } cout&lt;&lt;ans; return 0;} D - csp201812-4数据中心题目描述求最小生成树的最大边 输入一个无向图 输出最小生成树的最大边值 题目分析 直接Kruskal求出最小生成树的同时记录最大边值即可 注意：题目中给的root完全没用，原题的意思是：以root为根构造一棵树，求每一层的最大边值中的最大值 这不就是最小生成树的最大边值🐎，嗯？阅读理解题？ 代码12345678910111213141516171819202122232425262728293031323334353637383940const int maxx = 2e5+10;vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt; edge;int father[maxx];int find(int x){ return father[x] == x ? x : father[x] = find(father[x]);}void merge(int a,int b){ father[find(a)] = find(b); return ;}bool cmp(const pair&lt;int,pair&lt;int,int&gt; &gt;&amp; a,const pair&lt;int,pair&lt;int,int&gt; &gt;&amp; b) { return a.first &lt; b.first;}int main(){ int n,p,r,m; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r; for(int i = 1;i&lt;=n;i++) father[i] = i; for(int i = 1;i&lt;=m;i++){ int v,u,w; cin&gt;&gt;v&gt;&gt;u&gt;&gt;w; edge.push_back(make_pair(w,make_pair(u,v))); } sort(edge.begin(),edge.end(),cmp); int cnt = 0 ,ans = 0; for(auto &amp;i:edge){ int u = i.second.first; int v = i.second.second; int w = i.first; if( find(u) != find(v) ){ // cout&lt;&lt;u&lt;&lt;\" \"&lt;&lt;v&lt;&lt;\" \"&lt;&lt;w&lt;&lt;\"\\n\"; merge(u,v); ans = w; cnt++; } if(cnt == n-1) break; } cout&lt;&lt;ans; return 0;} 周模拟题 - 掌握魔法的东东2题目描述从瑞神家打牌回来后，东东痛定思痛，决定苦练牌技，终成赌神！东东有 A × B 张扑克牌。每张扑克牌有一个大小(整数，记为a，范围区间是 0 到 A - 1）和一个花色（整数，记为b，范围区间是 0 到 B - 1。扑克牌是互异的，也就是独一无二的，也就是说没有两张牌大小和花色都相同。“一手牌”的意思是你手里有5张不同的牌，这 5 张牌没有谁在前谁在后的顺序之分，它们可以形成一个牌型。 我们定义了 9 种牌型，如下是 9 种牌型的规则，我们用“低序号优先”来匹配牌型，即这“一手牌”从上到下满足的第一个牌型规则就是它的“牌型编号”（一个整数，属于1到9）： 同花顺: 同时满足规则 2 和规则 3. 顺子 : 5张牌的大小形如 x, x + 1, x + 2, x + 3, x + 4 同花 : 5张牌都是相同花色的. 炸弹 : 5张牌其中有4张牌的大小相等. 三带二 : 5张牌其中有3张牌的大小相等，且另外2张牌的大小也相等. 两对: 5张牌其中有2张牌的大小相等，且另外3张牌中2张牌的大小相等. 三条: 5张牌其中有3张牌的大小相等. 一对: 5张牌其中有2张牌的大小相等. 要不起: 这手牌不满足上述的牌型中任意一个. 现在, 东东从A × B 张扑克牌中拿走了 2 张牌！分别是 (a1, b1) 和 (a2, b2). （其中a表示大小，b表示花色）现在要从剩下的扑克牌中再随机拿出 3 张！组成一手牌！！其实东东除了会打代码，他业余还是一个魔法师，现在他要预言他的未来的可能性，即他将拿到的“一手牌”的可能性，我们用一个“牌型编号（一个整数，属于1到9）”来表示这手牌的牌型，那么他的未来有 9 种可能，但每种可能的方案数不一样。现在，东东的阿戈摩托之眼没了，你需要帮他算一算 9 种牌型中，每种牌型的方案数。 输入第 1 行包含了整数 A 和 B (5 ≤ A ≤ 25, 1 ≤ B ≤ 4). 第 2 行包含了整数 a1, b1, a2, b2 (0 ≤ a1, a2 ≤ A - 1, 0 ≤ b1, b2 ≤ B - 1, (a1, b1) ≠ (a2, b2)). 输出输出一行，这行有 9 个整数，每个整数代表了 9 种牌型的方案数（按牌型编号从小到大的顺序） 题目分析 因为已经抽走了两张牌，所以直接枚举剩下的三张牌就好，然后每次进行判断是那种牌型； 看数据范围没有问题 一些细节问题： 三带二、两对、三条、一对、炸弹都是要求统计数字相同的牌的数量，所以可以开大小为25（$5\\leq A\\leq25$）的数字桶，再套上大小为4（$1\\leq B\\leq4$）的数量桶，就可以非常方便地进行统计； 判断顺子/同花顺的时候需要对数组进行排序，这里应该是取数组的复制而不是直接排序原数组，否则会影响之后的枚举。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778int a[3],b[3];int num[26],cnt[5];int A,B;int ans[10];vector&lt;pair&lt;int,int&gt; &gt; card,hand;bool cmp(pair&lt;int,int&gt;&amp; a,pair&lt;int,int&gt;&amp; b){ if(a.first == b.first){ return a.second &lt; b.second; }else { return a.first &lt; b.first; }}int jud(vector&lt;pair&lt;int,int&gt; &gt; hand){ sort(hand.begin(),hand.end(),cmp); bool flag1 = 0; // shunzi for(int i = 1;i&lt;5;i++){ if(hand[i-1].first == hand[i].first-1){ flag1 = 1; }else {flag1 = 0;break;} } bool flag2 = 0 ; // tonghua int color = hand[0].second; for(auto &amp;i:hand){ if(color == i.second){ flag2 = 1; }else{ flag2 = 0;break; } } if(flag1 &amp;&amp; flag2) return 1; if(flag1) return 2; if(flag2) return 3; for(int i = 0; i&lt;=30;i++) num[i] = 0; for(auto &amp;i:hand){ num[i.first]++; } for(int i = 0;i&lt;=10;i++) cnt[i] = 0; for(int i = 0 ;i&lt;=30;i++) cnt[num[i]]++; if(cnt[4] == 1) return 4; if(cnt[3] == 1 &amp;&amp; cnt[2] == 1) return 5; if(cnt[2] == 2) return 6; if(cnt[3] == 1) return 7; if(cnt[2] == 1) return 8; return 9;}void dfs(int n,int pos){ if(n == 3){ ans[jud(hand)]++; return; } int size = card.size(); for(int i = pos;i&lt;size;i++){ hand.push_back(card[i]); dfs(n+1,i+1); hand.pop_back(); }}int main(){ cin&gt;&gt;A&gt;&gt;B; cin&gt;&gt;a[1]&gt;&gt;b[1]&gt;&gt;a[2]&gt;&gt;b[2]; for(int i = 0;i&lt;A;i++){ for(int j = 0;j&lt;B;j++){ if((i == a[1] &amp;&amp; j == b[1]) || (i == a[2] &amp;&amp; j== b[2])) { hand.push_back(make_pair(i,j)); }else card.push_back(make_pair(i,j)); } } dfs(0,0); for(int i = 1;i&lt;=9;i++){ cout&lt;&lt;ans[i]&lt;&lt;\" \"; } return 0;}","link":"/2020/03/31/程设Week6-作业/"},{"title":"程设Week7-作业","text":"本周各种最短路 A - TT 的魔法猫题目描述有一张游戏胜负表，上面有 N 个人以及 M 个胜负关系，每个胜负关系为 A B，表示 A 能胜过 B，且胜负关系具有传递性。即 A 胜过 B，B 胜过 C，则 A 也能胜过 C。 TT 不相信他的小猫咪什么比赛都能预测，因此他想知道有多少对选手的胜负无法预先得知 输入12345第一行给出数据组数。每组数据第一行给出 N 和 M（N , M &lt;= 500）。接下来 M 行，每行给出 A B，表示 A 可以胜过 B。 输出1对于每一组数据，判断有多少场比赛的胜负不能预先得知。注意 (a, b) 与 (b, a) 等价，即每一个二元组只被计算一次。 题目分析 因为有传递性，所以符合图的连通性。 因此可以直接01 floyd判断联通就可 要注意数据范围较大，考虑显然的剪枝：a如果无法到达k，那么就不用考虑k是否能到达b了 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;bool t[510][510];int main(){ ios::sync_with_stdio(false); int T; cin&gt;&gt;T; while(T--){ int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=n;j++){ t[i][j] = 0; } } for(int i = 1;i&lt;=m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; t[x][y] = 1; } for(int k = 1;k&lt;=n;k++) for(int i = 1;i&lt;=n;i++){ if(!t[i][k]) continue; // 可行性剪枝 for(int j = 1;j&lt;=n;j++){ if(t[i][k] &amp;&amp; t[k][j]){ t[i][j] = 1; } } } int ans = 0; for(int i = 1;i&lt;=n;i++){ for(int j = i+1;j&lt;=n;j++){ if(!t[i][j] &amp;&amp; !t[j][i])ans++; } } cout&lt;&lt;ans&lt;&lt;\"\\n\"; } return 0;} B - TT 的旅行日记题目描述TT 从家里出发，准备乘坐猫猫快线前往喵星机场。猫猫快线分为经济线和商业线两种，它们的速度与价钱都不同。当然啦，商业线要比经济线贵，TT 平常只能坐经济线，但是今天 TT 的魔法猫变出了一张商业线车票，可以坐一站商业线。假设 TT 换乘的时间忽略不计，请你帮 TT 找到一条去喵星机场最快的线路，不然就要误机了！ 输入输入包含多组数据。每组数据第一行为 3 个整数 N, S 和 E (2 ≤ N ≤ 500, 1 ≤ S, E ≤ 100)，即猫猫快线中的车站总数，起点和终点（即喵星机场所在站）编号。 下一行包含一个整数 M (1 ≤ M ≤ 1000)，即经济线的路段条数。 接下来有 M 行，每行 3 个整数 X, Y, Z (1 ≤ X, Y ≤ N, 1 ≤ Z ≤ 100)，表示 TT 可以乘坐经济线在车站 X 和车站 Y 之间往返，其中单程需要 Z 分钟。 下一行为商业线的路段条数 K (1 ≤ K ≤ 1000)。 接下来 K 行是商业线路段的描述，格式同经济线。 所有路段都是双向的，但有可能必须使用商业车票才能到达机场。保证最优解唯一。 输出对于每组数据，输出3行。第一行按访问顺序给出 TT 经过的各个车站（包括起点和终点），第二行是 TT 换乘商业线的车站编号（如果没有使用商业线车票，输出”Ticket Not Used”，不含引号），第三行是 TT 前往喵星机场花费的总时间。 本题不忽略多余的空格和制表符，且每一组答案间要输出一个换行 题目分析目前来说 一共有三种做法 先从起点终点开始分别跑两遍最短路，然后枚举所有商业线，并记录dis[s] + dis[e] + w 与不使用商业线的最小值。 dis数组加一维0/1，如果到当前节点使用了商业线则是1，未使用则是0.1则接下来只能向走非商业线连接的节点转移，如果是0则商业线和非商业线连接的节点都可以走。 分层图；两层图，所有商业线是第一层到第二层图的连接线，跑一边即可。 细节： 因为是万恶的多组数据，而且卡PE（可以说是十分恶心了），因此输出要十分注意不要多输出空格； 还要记得每组数据计算完之后清空各种数组、队列； 还要记得方法1的两段路径输出方式不一样; 还要记得dis初始值inf不能太大否则会溢出，推荐好用的0x3f3f3f3f； 总之十分十分难调，从方法二换到方法一，从SPFA换到DJi 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#define inf 30000000using namespace std;const int maxx = 510;vector&lt;pair&lt;pair&lt;int,int&gt;,int&gt; &gt; node[maxx];vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt; come;int n,s,e,m,k,business;bool inq[maxx];int dis[maxx][2];int pre[maxx][2];void output(int i,int t,int end){ if(i == end || pre[i][t] == 0){ cout&lt;&lt;i&lt;&lt;\" \"; }else{ output(pre[i][t],t,end); cout&lt;&lt;i&lt;&lt;\" \"; } return;}void output1(int i){ if(i == 0){ return; }else { cout&lt;&lt;i&lt;&lt;\" \"; output1(pre[i][1]); }}void output0(int i){ if(i == 0){ return; }else { output0(pre[i][0]); cout&lt;&lt;i&lt;&lt;\" \"; }}void spfa(int s,int t){ for(int i = 0;i&lt;=n;i++) inq[i] = 0; queue&lt;int&gt; q; q.push(s); dis[s][t]= 0; while(!q.empty()){ int h = q.front(); q.pop(); inq[h] = 0; for(auto &amp;i : node[h]){ int v = i.first.first,w = i.first.second; if(dis[h][t] + w &lt; dis[v][t]){ pre[v][t] = h; dis[v][t] = dis[h][t] + w; if(!inq[v]){ q.push(v); inq[v] = 1; } } } }}void dji(){ business = 0; dis[s][0] = dis[s][1] = 0; priority_queue&lt;pair&lt;int,int&gt; &gt; q; q.push(make_pair(0,s)); while(!q.empty()){ int h = q.top().second; q.pop(); if(inq[h]) continue; inq[h] = 1; for(auto &amp;i : node[h]){ int type = i.second,v = i.first.first,w = i.first.second; if(type == 0){ for(int t = 0;t&lt;=1;t++){ if(dis[h][t] + w &lt; dis[v][t]){ pre[v][t] = h; dis[v][t] = dis[h][t] + w; q.push(make_pair(-dis[v][t],v)); } } } else { if(dis[h][0] + w &lt; dis[v][1]){ pre[v][1] = h; dis[v][1] = dis[h][0] + w; business = h; q.push(make_pair(-dis[v][1],v)); } } } } if(dis[e][0] &gt; dis[e][1] &amp;&amp; business){ output(pre[business][0],0,s); output(e,1,business); cout&lt;&lt;\"\\n\"; cout&lt;&lt;business&lt;&lt;\"\\n\"&lt;&lt;dis[e][1]&lt;&lt;\"\\n\\n\"; } else { output(e,0,s); cout&lt;&lt;\"\\n\"; cout&lt;&lt;\"Ticket Not Used\\n\"&lt;&lt;dis[e][0]&lt;&lt;\"\\n\\n\"; }}int main(){ ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;s&gt;&gt;e){ for(int i = 0;i&lt;=n;i++){ dis[i][0] = dis[i][1] = inf; node[i].clear(); pre[i][0] = pre[i][1] = 0; } cin&gt;&gt;m; for(int i = 0;i &lt; m;i++){ int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; node[x].push_back(make_pair(make_pair(y,z),0)); node[y].push_back(make_pair(make_pair(x,z),0)); } cin&gt;&gt;k; for(int i = 0;i &lt; k;i++){ int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; // node[x].push_back(make_pair(make_pair(y,z),1)); come.push_back(make_pair(x,make_pair(y,z))); // node[y].push_back(make_pair(make_pair(x,z),1)); } spfa(s,0); spfa(e,1); int ans = dis[e][0] , l = 0 ,r = 0; for(auto &amp;i : come){ int u = i.first; int v = i.second.first; int w = i.second.second; if(dis[u][0] + dis[v][1] + w &lt; ans ){ ans = dis[u][0] + dis[v][1] + w; l = u,r = v; } if(dis[v][0] + dis[u][1] + w &lt; ans){ ans = dis[v][0] + dis[u][1] + w; l = v,r = u; } } if(ans != dis[e][0]){ output0(l); output1(r); cout&lt;&lt;\"\\n\"; cout&lt;&lt;l&lt;&lt;\"\\n\"&lt;&lt;ans&lt;&lt;\"\\n\\n\"; }else{ output0(e); cout&lt;&lt;\"\\n\"; cout&lt;&lt;\"Ticket Not Used\\n\"&lt;&lt;ans&lt;&lt;\"\\n\\n\"; } // dji(); } return 0;} C - TT 的美梦题目描述12345喵星上共有 M 条有向道路供商业城市相互往来。但是随着喵星商业的日渐繁荣，有些道路变得非常拥挤。正在 TT 为之苦恼之时，他的魔法小猫咪提出了一个解决方案！TT 欣然接受并针对该方案颁布了一项新的政策。具体政策如下：对每一个商业城市标记一个正整数，表示其繁荣程度，当每一只喵沿道路从一个商业城市走到另一个商业城市时，TT 都会收取它们（目的地繁荣程度 - 出发地繁荣程度）^ 3 的税。TT 打算测试一下这项政策是否合理，因此他想知道从首都出发，走到其他城市至少要交多少的税，如果总金额小于 3 或者无法到达请悄咪咪地打出 &apos;?&apos;。 输入12345678910111213第一行输入 T，表明共有 T 组数据。（1 &lt;= T &lt;= 50）对于每一组数据，第一行输入 N，表示点的个数。（1 &lt;= N &lt;= 200）第二行输入 N 个整数，表示 1 ～ N 点的权值 a[i]。（0 &lt;= a[i] &lt;= 20）第三行输入 M，表示有向道路的条数。（0 &lt;= M &lt;= 100000）接下来 M 行，每行有两个整数 A B，表示存在一条 A 到 B 的有向道路。接下来给出一个整数 Q，表示询问个数。（0 &lt;= Q &lt;= 100000）每一次询问给出一个 P，表示求 1 号点到 P 号点的最少税费。 输出1每个询问输出一行，如果不可达或税费小于 3 则输出 &apos;?&apos;。 题目分析 可能存在负环的最短路问题，直接用SPFA记录某个节点是否入队n次即可； 某个点入队n次-&gt; 这个点所在连通块有负环-&gt; 负环上所有点均不可到达-&gt; dfs该点记录一下； 输出描述有些问题，应该是每组数据前都要加一个Case x: 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#define inf 0x3f3f3f3fusing namespace std;int c[300];vector&lt;pair&lt;int,int&gt; &gt; node[300];int n,dis[300],vis[300],inq[300];int v[300];void dfs(int x){ if(v[x]) return; v[x] = 1; for(auto &amp;i:node[x]){ dfs(i.first); }}void spfa(){ queue&lt;int&gt; q; q.push(1); for(int i=1;i&lt;=n;i++) dis[i] = inf,v[i] = vis[i] = inq[i] = 0; dis[1] = 0; while(q.size()){ int h = q.front(); vis[h] = 0; q.pop(); for(auto &amp;i:node[h]){ if(!v[i.first] &amp;&amp; dis[h] + i.second &lt; dis[i.first]){ dis[i.first] = dis[h] + i.second; inq[i.first]++; if(inq[i.first] &gt;= n) { dfs(i.first); } if(!vis[i.first]){ vis[i.first] = 1; q.push(i.first); } } } }}int main(){ ios::sync_with_stdio(false); int T,cnt=0; cin&gt;&gt;T; while(T--){ cnt++; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;c[i]; node[i].clear(); } int m; cin&gt;&gt;m; for(int i = 1;i&lt;=m;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; node[a].push_back(make_pair(b,pow(c[b]-c[a],3))); } spfa(); int q; cin&gt;&gt;q; cout&lt;&lt;\"Case \"&lt;&lt;cnt&lt;&lt;\":\\n\"; while(q--){ int p; cin&gt;&gt;p; if(!v[p] &amp;&amp; dis[p] &gt;=3 &amp;&amp; dis[p]!=inf) cout&lt;&lt;dis[p]&lt;&lt;\"\\n\"; else cout&lt;&lt;\"?\\n\"; } }}","link":"/2020/04/13/程设Week7-作业/"},{"title":"程设Week8-作业","text":"DAG以及把不是DAG的题抽象成DAG 前置知识差分约束 什么是差分约束系统： 一种特殊的 n 元一次不等式组，它包含 n个变量以及m个约束条件。 每个约束条件是由两个其中的变量做差构成的，形如$𝑥_i−𝑥_j≤𝑐_k$， 其中$c_k$是常数（可以是非负数，也可以是负数）。 我们要解决的问题是：求一组解$𝑥_1=𝑎_1,𝑥_2=𝑎_2,…,𝑥_n=𝑎_n$，使得所有的约束条件得到满足，否则判断出无解 如何求解？ 对于差分约束中的每一个不等式约束$𝑥_i−𝑥_j≤𝑐_k$都可以移项变形为 $𝑥_i≤𝑐_k+𝑥_j$如果令$𝑐_k=𝑤(𝑖,𝑗)，𝑑𝑖𝑠_𝑖=𝑥_i，𝑑𝑖𝑠_𝑗=x_j$，那么原式变为$𝑑𝑖𝑠_𝑖≤ 𝑑𝑖𝑠_𝑗+𝑤(𝑖,𝑗)$，与最短路问题中的松弛操作相似 我们可以把变量$𝑥_i$看作图中的一个结点，对于每个不等式约束$𝑥_i− 𝑥_j≤𝑐_k$，从结点𝑗到节点𝑖连一条长度为$c_k $的有向边。在图上求最短路即可求得最大解 （$\\textbf{x} \\leq \\textbf{c}$中的 $ \\textbf{x} $为上界）。 出现负环？ 如果路径中存在负环则表现为最短路的无限小，即最短路不存在 在不等式约束上表现为$𝑥_i−𝑥_j≤𝑐_k$中的T为无限小 得出的结论就是$x_i$的结果不存在 可以通过Bellman算法或者队列优化的Bellman算法（SPFA）来判 断负环是否存在 点i不可达？ 说明i与1之间没有约束关系，$x_i$可以是任意值。 A-区间选点 II题目描述：给定一个数轴上的 n 个区间，要求在数轴上选取最少的点使得第 i 个区间 [ai, bi] 里至少有 ci 个点 使用差分约束系统的解法解决这道题 输入输入第一行一个整数 n 表示区间的个数，接下来的 n 行，每一行两个用空格隔开的整数 a，b 表示区间的左右端点。1 &lt;= n &lt;= 50000， 0 &lt;= ai &lt;= bi &lt;= 50000 并且 1 &lt;= ci &lt;= bi - ai+1。 输出输出一个整数表示最少选取的点的个数 题目分析 可以对数轴上点分布的前缀和数组r做差分约束： $r[b_i] - r[a_i-1] \\geq c_i$ 同时，每个点最多放一个点，最少放0个点： $r[i] - r[i-1] \\leq 1$ $r[i] - r[i-1] \\geq 0$ 直接跑最短路，并输出dis[max(bi)]即可 亿些细节： 注意给定的左右区间不一定是从1开始的，要自己记录； 注意先统一不等号； 这波又卡vector，还是老实用前向星 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using namespace std;const int maxx = 5e4+10;const int inf = 0x3f3f3f3f;int n,dis[maxx];bool inq[maxx];struct rec{ int v,w,next;}edge[maxx*4];int head[maxx],p;void add(int a,int b,int c){ p++; edge[p].v = b; edge[p].w = c; edge[p].next = head[a]; head[a] = p;}void spfa(int s){ for(int i = 1;i&lt;=n;i++){ dis[i] = inf; inq[i] = 0; } dis[s] = 0; queue&lt;int&gt; q; q.push(s); inq[s] = 1; while(q.size()){ int h = q.front(); inq[h] = 0; q.pop(); for(int i = head[h];i;i = edge[i].next){ int v = edge[i].v; int w = edge[i].w; if(dis[h] + w &lt; dis[v]){ dis[v] = dis[h] + w; if(!inq[v]){ inq[v] = 1; q.push(v); } } } }}int main(){ ios::sync_with_stdio(false); int cnt = 0,s = inf; n = 0; cin&gt;&gt;cnt; for(int i = 1;i&lt;=cnt;i++){ int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a-1,b,-c); n = max(n,b); s = min(s,a-1); } for(int i = s;i&lt;n;i++){ add(i+1,i,1); add(i,i+1,0); } spfa(s); cout&lt;&lt;-dis[n]; return 0;} B-猫猫向前冲题目描述拓扑排序 输入输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示猫猫的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即编号为 P1 的猫猫赢了编号为 P2 的猫猫。 输出给出一个符合要求的排名。输出时猫猫的编号之间有空格，最后一名后面没有空格! 其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。 题目分析 就是简单粗暴的拓扑排序，只记录边，直接用堆排序编号就可。每次将入度为0的点压进去，弹出来堆顶的节点去更新与其相连的点，并把更新之后入度变成0的节点压进堆。 多组数据，每次记得清空。 不支持c++11，不能用auto有点难受。 代码123456789101112131415161718192021222324252627282930313233343536373839using namespace std;int n,m;vector&lt;int&gt; edge[600];int d[600];int main(){ n,m; while(cin&gt;&gt;n&gt;&gt;m){ priority_queue&lt;int&gt; q; for(int i = 1;i&lt;=m;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; edge[a].push_back(b); d[b]++; } for(int i = 1;i&lt;=n;i++){ if(d[i] == 0) q.push(-i); } int cnt = 0; while(q.size()){ if(cnt == n-1)break; int u = -q.top(); cout&lt;&lt;u&lt;&lt;\" \"; q.pop(); cnt++; int len = edge[u].size(); for(int i = 0;i&lt;len;i++){ d[edge[u][i]]--; if(d[edge[u][i]] == 0){ q.push(-edge[u][i]); } } } cout&lt;&lt;-q.top()&lt;&lt;\"\\n\"; for(int i = 0;i&lt;=n;i++){ d[i] = 0; edge[i].clear(); } }} C-班长竞选题目描述大学班级选班长，N 个同学均可以发表意见 若意见为 A B 则表示 A 认为 B 合适，意见具有传递性，即 A 认为 B 合适，B 认为 C 合适，则 A 也认为 C 合适 勤劳的 TT 收集了M条意见，想要知道最高票数，并给出一份候选人名单，即所有得票最多的同学，你能帮帮他吗？ 输入本题有多组数据。第一行 T 表示数据组数。每组数据开始有两个整数 N 和 M (2 &lt;= n &lt;= 5000, 0 &lt;m &lt;= 30000)，接下来有 M 行包含两个整数 A 和 B(A != B) 表示 A 认为 B 合适。 输出对于每组数据，第一行输出 “Case x: ”，x 表示数据的编号，从1开始，紧跟着是最高的票数。 接下来一行输出得票最多的同学的编号，用空格隔开，不忽略行末空格！ 题目分析 关键句： A 认为 B 合适，B 认为 C 合适，则 A 也认为 C 合适。那么同一连通块里的人可以获得： 其所在连通块中的所有人的票 连到该连通块的所有其他连通块的票 那么直接将连通块缩为点，点权即为该连通块的大小。 如何求最多的？ 直接遍历？实操比较麻烦，因为可能会有多个入度为0的点，这些点可能会有相同的后代，因此还要判断某连通块的票数是否已经加过balabala。。。 不难想到获得票数最多的连通块必然是没有出边的。因为如果有出边，那么该边连到的另一连通块的票数必然比当前连通块多； 那么不如直接构造缩点之后的反向图，那就可以从所有入度为0的节点（可能成为答案的节点）起遍历而不用考虑重复问题了，因为这样一次就可以考虑到所有能到达候选点的点。直接记录点权和即可算出某一候选点的最终票数。 亿点点细节： 多组数据记得清空 依旧卡vector 输出按照字典序排列 scnt是缩点的个数，n是点的个数，dfn是点对应dfs逆后序的编号不是点的编号，莫要搞混 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495using namespace std;const int N = 5010;int c[N],dfn[N],vis[N],dcnt,scnt,ct[N],d[N],vote[N];int n,m;struct rec{ int v,next;}G1[N*10],G2[N*10],G[N*10];int head[N],head1[N],head2[N],p,p1,p2;bool v[N];void add(int u,int v,rec g[],int&amp; pp,int hd[]){ pp++; g[pp].v = v; g[pp].next = hd[u]; hd[u] = pp;}void dfs1(int x){ vis[x] = 1; for(int e = head1[x];e;e = G1[e].next){ int y = G1[e].v; if(!vis[y]) dfs1(y); } dfn[++dcnt] = x;}void dfs2(int x){ c[x] = scnt; ++ct[scnt]; for(int e = head2[x];e;e = G2[e].next){ int y = G2[e].v; if(!c[y]) dfs2(y); }}void kosaraju(){ dcnt = scnt = 0; memset(c,0,sizeof(c)); memset(vis,0,sizeof(vis)); for(int i = 0;i&lt;n;i++){ if(!vis[i]) dfs1(i); } for(int i = n-1;i&gt;=0;i--){ if(!c[dfn[i]]) ++scnt,dfs2(dfn[i]); }}int dfs(int x){ v[x] = 1; int sum = ct[x]; for(int e = head[x];e;e = G[e].next){ int y = G[e].v; if(!v[y]) sum += dfs(y); } return sum;}int main(){ int T,k=0; cin&gt;&gt;T; while(k++&lt;T){ cin&gt;&gt;n&gt;&gt;m; for(int i = 1;i&lt;=m;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b,G1,p1,head1); add(b,a,G2,p2,head2); } kosaraju(); for(int i = 0;i&lt;n;i++){ for(int e = head1[i];e;e = G1[e].next){ int y = G1[e].v; if(c[y] != c[i]){ add(c[y],c[i],G,p,head); d[c[i]]++; } } } int ans = 0; for(int i = 1;i&lt;=scnt;i++){ if(d[i] == 0){ memset(v,0,sizeof(v)); vote[i] = dfs(i); ans = max(ans,vote[i]); } } cout&lt;&lt;\"Case \"&lt;&lt;k&lt;&lt;\": \"&lt;&lt;ans-1&lt;&lt;\"\\n\"; vector&lt;int&gt; anses; for(int i = 0;i&lt;n;i++){ if(vote[c[i]] == ans){ anses.push_back(i); } } cout&lt;&lt;anses[0]; for(int i = 1;i &lt; anses.size();i++) cout&lt;&lt;\" \"&lt;&lt;anses[i]; cout&lt;&lt;\"\\n\"; for(int i = 0;i &lt;= scnt;i++) ct[i] = d[i] = vote[i] = 0 ; for(int i = 0;i&lt;= n;i++) head[i] = head1[i] = head2[i] = 0; p = p1 = p2 = 0; }}","link":"/2020/04/13/程设Week8-作业/"},{"title":"程设Week8-模拟","text":"T3最后一分钟没交上啊啊啊啊啊啊啊啊 以后看都不看先打暴力！！！ 下次一定！！！ T1 序列有一个序列a，问是否存在一个K，让a中的一些数+K或者-K或者不变，最后序列中所有的数相等。 输入输入第一行是一个正整数 表示数据组数。 接下来对于每组数据，输入的第一个正整数 表示序列 的长 度，随后一行有 个整数，表示序列 。 输出输出共包含 行，每组数据输出一行。对于每组数据，如果存在这样的K，输出”YES”，否则输出“NO”。 （输出不包含引号） 题目分析 一开始以为是平均数，后来想T3的时候突然惊觉好像不对劲，赶紧回来改了。 序列a中最多存在3种不同的数：一种是数A，一种是+K=A，一种是-K=A 序列a中存在1/2种数：必然存在K； 序列a中存在3种数：sort一下判断差值是否相等，如果相等则可以 序列a中存在多于三种数：必然不存在K 代码1234567891011121314151617181920212223242526int n;long long k,nums[10100];int main(){ ios::sync_with_stdio(false); int t; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; int cnt = 0; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;k; bool flag = 0; for(int j = 0;j&lt;cnt;j++) if(nums[j] == k) flag = 1; if(!flag) nums[cnt++] = k; } if(cnt&gt;3) {cout&lt;&lt;\"NO\\n\";} else if(cnt == 3){ sort(nums,nums+cnt); if(nums[2]-nums[1] == nums[1] - nums[0]) cout&lt;&lt;\"YES\\n\"; else cout&lt;&lt;\"NO\\n\"; }else{ cout&lt;&lt;\"YES\\n\"; } } return 0;} T2 学英语题目描述给定一个字符串，字符串中包括26个大写字母和特殊字 符’?’，特殊字符’？’可以代表任何一个大写字母。现在TT问你是否存在一个位置连续的且由26个大写字 母组成的子串，在这个子串中每个字母出现且仅出现一次，如果存在，请输出从左侧算起的第一个出现 的符合要求的子串，并且要求，如果有多组解同时符合位置最靠左，则输出字典序最小的那个解 输入输入只有一行，一个符合题目描述的字符串。 输出输出只有一行，如果存在这样的子串，请输出，否则输出-1 题目分析 因为看到连续子串，所以考虑尺取类似的方法。（其实更像滑动窗口？ 右端点右移的条件：前面的串不够26长 右移时把新的一位加入到当前子串的字符记录里 左端点右移的条件：当前串不符合要求（没有26个不一样的英文字母 右移时把旧的一位从当前子串的字符记录里删除 字典序最小只需要最后算出剩余字母并按字典序从前向后填充?的位置 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int n;int sp[30];int main(){ ios::sync_with_stdio(false); string s; cin&gt;&gt;s; int len = s.length(),l = -1, r = 0,cnt = 0; if(s[0]!='?') {sp[s[0] - 'A']++; cnt++;} else sp[26]++; while(r&lt;len){ if(r-l &lt; 26) { r++; if(r == len) break; if(s[r]!='?'){ if(!sp[s[r]-'A']){ cnt++; } sp[s[r] - 'A']++; } else sp[26]++; }else { if(r-l == 26){ if(cnt + sp[26] == 26){ char block[26]; int ct = 0; for(int i = 25;i&gt;=0;i--){ if(!sp[i]) block[ct++] = i+'A'; } for(int i = l+1;i&lt;=r;i++){ if(s[i] != '?')cout&lt;&lt;s[i]; else cout&lt;&lt;block[--ct]; } return 0; }else { l++; if(s[l]!='?'){ sp[s[l] - 'A']--; if(!sp[s[l]-'A']){ cnt--; } } else sp[26]--; } } } } cout&lt;&lt;\"-1\"; return 0;} T3 奇妙序列有一个奇怪的无限序列：112123123412345 ……这个序列由连续正整数组成的若干部分构成，其 中第一部分包含1至1之间的所有数字，第二部分包含1至2之间的所有数字，第三部分包含1至3之间的所 有数字，第i部分总是包含1至i之间的所有数字。所以，这个序列的前56项会是 11212312341234512345612345671234567812345678912345678910，其中第1项是1，第3项是2，第20项是 5，第38项是2，第56项是0。咕咕东 现在想知道第 k 项数字是多少 输入输入由多行组成。第一行一个整数q表示有q组询问接下来第i+1行表示第i个输入 ，表示询问第 项数字 输出输出包含q行第i行输出对询问 的输出结果。 题目分析 记1为第一轮，12为第二轮，1….n第n轮； 记1121231234…9为数列a1，1..1011/1…101112……99为数列2….. 那么可以轻易算出来数列1-8所包含的数字数量： 数列1为首项为1公差为1大小为9的等差数列 数列2为首项为10公差为2大小为90的等差数列 … 等差数列求和不用我多说了8，再顺便求个前缀和也很easy 1-8的数列就已经包含到$10^{20}$位数字了，所以我们只需要把输入和前缀和数组相比较，就可以知道要找的数在哪个数列里； 知道了在哪个数列，然后就要算在哪个轮次里。 由于数列8的大小为$9\\times10^8$，因此需要在这里用一次二分，算一下要求的数在哪个轮次； 然后就和上面差不多，我们可以算出1到9是9*1=9位，10到99是902=180位…最多$9\\times 10 ^ 8 \\times 8$位，那么最多只需要比较8次我们就可以知道*要求的数的所在数字**有几位，假设有k位； 那么只需要所在数字-(前置数列总数字个数+前置轮次总数字个数+前置不同位数字总数字个数)/k = n ...m 那么所求数字就是当前位数数字的开头数字+（n - 1） * 数字位数（+1）是否加一取决于余数m 细节： 如果余数m==0，那么要取前一个数的末尾数字；否则直接从当前的数截取； 因为很多地方用到了10的幂（算位数、最后截取），因此可以直接预处理出10的幂数组方便使用; 注意开longlong 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using namespace std;unsigned long long ten[20];struct req{ unsigned long long a0,d,n,an; unsigned long long sum; req(){} req(unsigned long long a0,unsigned long long d,unsigned long long n):a0(a0),d(d),n(n){ sum = (a0+a0+(n-1)*d)*n/2; an = a0+(n-1)*d; }}a[100],b[100];unsigned long long c[30],d[30];int main(){ ten[0] = 1; for(int i = 1;i&lt;=18;i++) ten[i] = ten[i-1] * 10; a[1] = req(1,1,9); c[1] = a[1].sum; for(int i = 2;i &lt;= 9;i++){ a[i] = req(a[i-1].an + i,i,9*ten[i-1]); c[i] = c[i-1] + a[i].sum; } for(int i = 1;i &lt;= 18;i++){ b[i] = req(ten[i-1],0,9*ten[i-1]); d[i] = d[i-1] + i*9*ten[i-1]; } int q; cin&gt;&gt;q; while(q--){ unsigned long long k,p = 0,p1 = 0; cin&gt;&gt;k; for(int i = 1;i&lt;=9;i++){ if(c[i] &gt; k) {p = i-1;break;} } unsigned long long las = k-c[p]; p = p+1; long long l = 0,r = a[p].n; while(l&lt;=r){ long long mid = (l+r)&gt;&gt;1; if((a[p].a0 + a[p].a0 + (mid-1) * a[p].d)*mid/2 &gt;= las){ r = mid - 1; }else { l = mid + 1; } } unsigned long long k1 = las - (a[p].a0 + a[p].a0 + (r-1) * a[p].d)*r/2; for(int i = 1;i&lt;=18;i++){ if(d[i] &gt; k1) {p1 = i-1;break;} } unsigned long long la = k1 - d[p1]; int bits = p1+1; unsigned long long s = la/bits,yu = la-s*bits; unsigned long long num = b[bits].a0 + s ; // cout&lt;&lt;num&lt;&lt;\"\\n\"; if(yu == 0) cout&lt;&lt;(num-1)%10&lt;&lt;\"\\n\"; else cout&lt;&lt;num/ten[bits-yu]%10&lt;&lt;\"\\n\"; }}","link":"/2020/04/13/程设Week8-模拟/"},{"title":"程设Week9-作业","text":"博客一定不能拖，不能拖 A-咕咕东的目录管理器题目描述咕咕东的雪梨电脑的操作系统在上个月受到宇宙射线的影响，时不时发生故障，他受不了了，想要写一个高效易用零bug的操作系统 —— 这工程量太大了，所以他定了一个小目标，从实现一个目录管理器开始。前些日子，东东的电脑终于因为过度收到宇宙射线的影响而宕机，无法写代码。他的好友TT正忙着在B站看猫片，另一位好友瑞神正忙着打守望先锋。现在只有你能帮助东东！ 初始时，咕咕东的硬盘是空的，命令行的当前目录为根目录 root。 目录管理器可以理解为要维护一棵有根树结构，每个目录的儿子必须保持字典序。 现在咕咕东可以在命令行下执行以下表格中描述的命令： 命令 类型 实现 说明 MKDIR s 操作 在当前目录下创建一个子目录 s，s 是一个字符串 创建成功输出 “OK”；若当前目录下已有该子目录则输出 “ERR” RM s 操作 在当前目录下删除子目录 s，s 是一个字符串 删除成功输出 “OK”；若当前目录下该子目录不存在则输出 “ERR” CD s 操作 进入一个子目录 s，s 是一个字符串（执行后，当前目录可能会改变） 进入成功输出 “OK”；若当前目录下该子目录不存在则输出 “ERR” 特殊地，若 s 等于 “..” 则表示返回上级目录，同理，返回成功输出 “OK”，返回失败（当前目录已是根目录没有上级目录）则输出 “ERR” SZ 询问 输出当前目录的大小 也即输出 1+当前目录的子目录数 LS 询问 输出多行表示当前目录的 “直接子目录” 名 若没有子目录，则输出 “EMPTY”；若子目录数属于 [1,10] 则全部输出；若子目录数大于 10，则输出前 5 个，再输出一行 “…”，输出后 5 个。 TREE 询问 输出多行表示以当前目录为根的子树的前序遍历结果 若没有后代目录，则输出 “EMPTY”；若后代目录数+1（当前目录）属于 [1,10] 则全部输出；若后代目录数+1（当前目录）大于 10，则输出前 5 个，再输出一行 “…”，输出后 5 个。若目录结构如上图，当前目录为 “root” 执行结果如下， UNDO 特殊 撤销操作 撤销最近一个 “成功执行” 的操作（即MKDIR或RM或CD）的影响，撤销成功输出 “OK” 失败或者没有操作用于撤销则输出 “ERR” 输入输入文件包含多组测试数据，第一行输入一个整数表示测试数据的组数 T （T &lt;= 20）； 每组测试数据的第一行输入一个整数表示该组测试数据的命令总数 Q （Q &lt;= 1e5）； 每组测试数据的 2 ~ Q+1 行为具体的操作 （MKDIR、RM 操作总数不超过 5000）； 输出每组测试数据的输出结果间需要输出一行空行。注意大小写敏感。 题目分析 因为有各种操作，且各种操作都是基于“目录”的，因此可以将操作直接封装到dir类里，调用时更清晰，也方便debug。 从数据范围可以知道，每次直接遍历求Tree/Size的话会直接爆炸（$1e5\\times 5k\\times 20$） MKDIR就是加入子节点，RM就是减去子节点，CD就是将当前节点换到某个指定的子节点，LS判断一下儿子节点个数输出即可，较容易实现； 在进行上述操作（MKDIR/RM）时，同时维护根节点到当前增删的节点路径上的所有节点的Size值，那么sz操作即可O(1)； TREE操作中，要求输出先序遍历的前后五个比较麻烦。但是可以注意到Q远大于MKDIR的数量，也就是说必然有很多Q重复询问同一节点； 字典序可以用map或者set快速实现； 那么我们可以考虑懒操作：只有当访问某节点的pre（前序前五个元素）和bck（前序后五个）且该节点的子树上发生过增/删节点操作时，才重新计算Tree；且要求的是前后五个，那么前五个就是从最左边的儿子节点pre数组开始找，后五个就是从最右边的bck数组开始找； 那么如此操作则将问题下放到了儿子节点，从而用相关的儿子节点信息进行本身的更新。本质上跟带lazy标记的线段树思想是相同的； 那么MKDIR/RM的同时还需要维护一个lazy标记表示某节点的子树中发生了更改，之前的信息不可用需要重新计算； 最后是UNDO操作，仅和增删和CD操作发生互动。 直接建立一个history栈，把MKDIR、RM、CD操作都压进栈，取出的时候逆向操作一下就可。 值得注意的是，如果将某个有子节点的节点删除，UNDO的时候也要把子节点一起恢复，也就是说建A—…—删A—建A—UNDO—UNDO的时候恢复的应该是第一次简历的A及其子目录。因此就算同名文件夹也不能覆盖掉之前的同名记录。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;map&gt;using namespace std;const int maxn = 1e6+10;int p;struct Dir{ int size,father; int id; string name; bool tag; map&lt;string,int&gt; child; vector&lt;string&gt; pre,bck; void init(string s,int fa,int idd){ name = s; father = fa; id = idd; tag = 0; size = 1; pre.clear();bck.clear();child.clear(); } int rm(string s){ if(!child.count(s)) {cout&lt;&lt;\"ERR\\n\";return -1;} else { int k = child[s]; child.erase(s); cout&lt;&lt;\"OK\\n\"; return k; } } int cd(string s){ if((s != \"..\" &amp;&amp; !child.count(s) )|| (s == \"..\" &amp;&amp; father == -1)) {cout&lt;&lt;\"ERR\\n\";return -1;} else { cout&lt;&lt;\"OK\\n\"; if(s == \"..\") return father; else return child[s]; } } void ls(){ if(child.size() &gt; 10){ int k = 5; auto i = child.begin(); while(k--){ cout&lt;&lt;i-&gt;first&lt;&lt;\"\\n\"; i++; } i = child.end(); cout&lt;&lt;\"...\\n\"; while(++k&lt;5) i--; while(k--){cout&lt;&lt;i-&gt;first&lt;&lt;\"\\n\";i++;} }else if(child.size() == 0 ){ cout&lt;&lt;\"EMPTY\\n\"; }else { for(auto &amp;i:child){ cout&lt;&lt;i.first&lt;&lt;\"\\n\"; } } }}node[maxn];int mkdir(int id,string s){ if(node[id].child.count(s)){ cout&lt;&lt;\"ERR\\n\";return -1;} else { p++; node[id].child[s] = p; node[p].init(s,id,p); cout&lt;&lt;\"OK\\n\"; return p; }}struct Commander{ int now; stack&lt;pair&lt;string,pair&lt;string,int&gt; &gt; &gt;his; void update(int id,int num){ while(id != -1){ node[id].size += num; node[id].tag = 0; id = node[id].father; } } void order(string order,string s=\"\"){ if(order == \"MKDIR\") { int k = mkdir(now,s); if(k!=-1) { update(now,1); his.push(make_pair(order,make_pair(s,k))); } } if(order == \"SZ\") { cout&lt;&lt;node[now].size&lt;&lt;\"\\n\"; } if(order == \"RM\") { int k = node[now].rm(s); if(k!=-1) { update(now,-node[k].size); his.push(make_pair(order,make_pair(s,k))); } } if(order == \"LS\") { node[now].ls(); } if(order == \"CD\") { int k = node[now].cd(s); if(k != -1){ his.push(make_pair(order,make_pair(\"\",now))); now = k; } } if(order == \"TREE\") { tree(); } if(order == \"UNDO\") { undo(); } } void undo(){ if(his.size()){ pair&lt;string,pair&lt;string,int&gt; &gt; pre = his.top(); his.pop(); if(pre.first == \"CD\") { now = pre.second.second; cout&lt;&lt;\"OK\\n\"; } if(pre.first == \"MKDIR\") { int k = pre.second.second; node[now].child.erase(pre.second.first); update(now,-node[k].size); cout&lt;&lt;\"OK\\n\"; } if(pre.first == \"RM\") { int k = node[now].child[pre.second.first] = pre.second.second; update(now,node[k].size); cout&lt;&lt;\"OK\\n\"; } }else { cout&lt;&lt;\"ERR\\n\"; } } void pretrack(int id){ node[id].pre.push_back(node[id].name); for(auto &amp;i:node[id].child){ if(!node[i.second].tag) pushdown(i.second); int cnt = 0; while(node[id].pre.size() &lt;= 20 &amp;&amp; cnt &lt; node[i.second].pre.size()){ node[id].pre.push_back(node[i.second].pre[cnt++]); } if(node[id].pre.size() &gt;= 10) return; } } void backtrack(int id){ auto i = node[id].child.end(); i--; for(;;i--) { if(!node[i-&gt;second].tag) pushdown(i-&gt;second); int cnt = 0; while(node[id].bck.size()&lt;=20 &amp;&amp; cnt &lt; node[i-&gt;second].bck.size()){ node[id].bck.push_back(node[i-&gt;second].bck[cnt++]); } if(node[id].bck.size() &gt;= 5) return; if(i == node[id].child.begin()) return ; // 必须要把begin加进去！！ } } void pushdown(int id){ node[id].pre.clear(); node[id].bck.clear(); pretrack(id); if(node[id].size&gt;10) backtrack(id); else { node[id].bck = node[id].pre; reverse(node[id].bck.begin(),node[id].bck.end()); } node[id].tag = 1; } void tree(){ if(!node[now].tag) pushdown(now); if(node[now].size == 1) cout&lt;&lt;\"EMPTY\\n\"; else if(node[now].size &lt;=10) for(int i = 0;i&lt;node[now].pre.size();i++) cout&lt;&lt;node[now].pre[i]&lt;&lt;\"\\n\"; else { int bsize = node[now].bck.size(); if(bsize-1 &lt; 4){ backtrack(now); } { for(int i = 0;i&lt;5;i++) cout&lt;&lt;node[now].pre[i]&lt;&lt;\"\\n\"; cout&lt;&lt;\"...\\n\"; for(int i = 4;i&gt;=0;i--) cout&lt;&lt;node[now].bck.at(i)&lt;&lt;\"\\n\"; } } } void init(){ now = 0; while(his.size()) his.pop(); node[0].init(\"root\",-1,0); }}cmd;int main(){ ios::sync_with_stdio(false); int T; cin&gt;&gt;T; while(T--){ p = 0 ; cmd.init(); int Q; cin&gt;&gt;Q; for(int i = 1;i&lt;=Q;i++){ string s; cin&gt;&gt;s; if(s == \"MKDIR\" || s == \"CD\" || s == \"RM\" ){ string ss; cin&gt;&gt;ss; cmd.order(s,ss); }else { cmd.order(s); } } }} B- 东东学打牌题目描述最近，东东沉迷于打牌。所以他找到 HRZ、ZJM 等人和他一起打牌。由于人数众多，东东稍微修改了亿下游戏规则： 所有扑克牌只按数字来算大小，忽略花色。 每张扑克牌的大小由一个值表示。A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K 分别指代 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13。 每个玩家抽得 5 张扑克牌，组成一手牌！（每种扑克牌的张数是无限的，你不用担心，东东家里有无数副扑克牌） 理所当然地，一手牌是有不同类型，并且有大小之分的。 举个栗子，现在东东的 “一手牌”（记为 α），瑞神的 “一手牌”（记为 β），要么 α &gt; β，要么 α &lt; β，要么 α = β。 那么这两个 “一手牌”，如何进行比较大小呢？首先对于不同类型的一手牌，其值的大小即下面的标号；对于同类型的一手牌，根据组成这手牌的 5 张牌不同，其值不同。下面依次列举了这手牌的形成规则： 大牌：这手牌不符合下面任一个形成规则。如果 α 和 β 都是大牌，那么定义它们的大小为组成这手牌的 5 张牌的大小总和。 对子：5 张牌中有 2 张牌的值相等。如果 α 和 β 都是对子，比较这个 “对子” 的大小，如果 α 和 β 的 “对子” 大小相等，那么比较剩下 3 张牌的总和。 两对：5 张牌中有两个不同的对子。如果 α 和 β 都是两对，先比较双方较大的那个对子，如果相等，再比较双方较小的那个对子，如果还相等，只能比较 5 张牌中的最后那张牌组不成对子的牌。 三个：5 张牌中有 3 张牌的值相等。如果 α 和 β 都是 “三个”，比较这个 “三个” 的大小，如果 α 和 β 的 “三个” 大小相等，那么比较剩下 2 张牌的总和。 三带二：5 张牌中有 3 张牌的值相等，另外 2 张牌值也相等。如果 α 和 β 都是 “三带二”，先比较它们的 “三个” 的大小，如果相等，再比较 “对子” 的大小。 炸弹：5 张牌中有 4 张牌的值相等。如果 α 和 β 都是 “炸弹”，比较 “炸弹” 的大小，如果相等，比较剩下那张牌的大小。 顺子：5 张牌中形成 x, x+1, x+2, x+3, x+4。如果 α 和 β 都是 “顺子”，直接比较两个顺子的最大值。 龙顺：5 张牌分别为 10、J、Q、K、A。 作为一个称职的魔法师，东东得知了全场人手里 5 张牌的情况。他现在要输出一个排行榜。排行榜按照选手们的 “一手牌” 大小进行排序，如果两个选手的牌相等，那么人名字典序小的排在前面。 不料，此时一束宇宙射线扫过，为了躲避宇宙射线，东东慌乱中清空了他脑中的 Cache。请你告诉东东，全场人的排名 输入输入包含多组数据。每组输入开头一个整数 n (1 &lt;= n &lt;= 1e5)，表明全场共多少人。随后是 n 行，每行一个字符串 s1 和 s2 （1 &lt;= |s1|,|s2| &lt;= 10）， s1 是对应人的名字，s2 是他手里的牌情况。 输出对于每组测试数据，输出 n 行，即这次全场人的排名。 题目分析 确实没啥好分析的，题目说啥就写啥就行了 主要逻辑在运算符重载上，但是写的时候可读性挺差的，麻烦的地方在于对子/两对/三带二重复域的处理上。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int maxx = 1e5+100;using namespace std;struct p{ string name; int cards[10]; int num[20]; int sum,prority,sMax,dNum,dui[5],san; void caculate(){ dNum = sum = sMax = prority = sum = san = 0; for(int i = 1;i&lt;=13;i++) num[i] = 0; for(int i = 0;i&lt;5;i++){ num[cards[i]]++; } if(num[1] &amp;&amp; num[10] &amp;&amp; num[11]&amp;&amp; num[12]&amp;&amp; num[13]) { prority = 8; return; }else { for(int i = 1;i&lt;10;i++){ if(num[i] &amp;&amp; num[i+1] &amp;&amp; num[i+2]&amp;&amp; num[i+3] &amp;&amp; num[i+4]){ prority = 7; sMax = i+4; return; } } bool flag = 0; for(int i = 1;i&lt;=13;i++){ if(num[i] &gt;= 4){ prority = 6; sMax = i; if(num[i] == 5) sum = i; }else if(num[i] == 3){ prority = 5; san = i; }else if(num[i] == 2){ dui[dNum++] = i; }else if(num[i] == 1){ sum += i; } } return; } } bool operator &lt;(const p&amp; b) const { if(prority == b.prority){ if(prority == 7) { if(sMax == b.sMax) return name &lt; b.name; else return sMax &gt; b.sMax; }else if(prority == 6){ if(sMax == b.sMax) { if(sum == b.sum) return name &lt; b.name; else return sum &gt; b.sum; }else return sMax &gt; b.sMax; }else if(prority == 5){ if(dNum &amp;&amp; b.dNum){ if(san == b.san){ if(dui[dNum-1] == b.dui[b.dNum-1]){ return name &lt; b.name; }else return dui[dNum-1] &gt; b.dui[b.dNum-1]; }else return san &gt; b.san; }else if(!dNum &amp;&amp; !b.dNum){ if(san == b.san){ if(sum == b.sum) return name &lt; b.name; else return sum &gt; b.sum; }else return san &gt; b.san; }else return dNum &gt; b.dNum; }else { if(dNum == b.dNum ){ if(dNum == 2){ return dui[dNum-1] == b.dui[b.dNum-1] ? ( dui[dNum-2] == b.dui[b.dNum-2] ? ( sum == b.sum ? name &lt; b.name : sum &gt; b.sum ) : dui[dNum-2] &gt; b.dui[b.dNum-2] ) : dui[dNum-1] &gt; b.dui[b.dNum-1] ; } if(dNum == 1){ return dui[dNum-1] == b.dui[b.dNum-1] ? ( sum == b.sum ? name &lt; b.name : sum &gt; b.sum ) : dui[dNum-1] &gt; b.dui[b.dNum-1] ; } if(dNum == 0){ return sum == b.sum ? name &lt; b.name : sum &gt; b.sum; } }else return dNum &gt; b.dNum; } }else return prority &gt; b.prority; }}Person[maxx];int main(){ int n; while(cin&gt;&gt;n){ for(int i = 0;i&lt;n;i++){ cin &gt;&gt; Person[i].name; for(int j = 0;j &lt;= 4;j++){ char c;cin&gt;&gt;c; if(c == 'A'){ Person[i].cards[j] = 1; }else if(c == 'J'){ Person[i].cards[j] = 11; }else if(c == 'Q'){ Person[i].cards[j] = 12; }else if(c == 'K'){ Person[i].cards[j] = 13; }else if(c == '1'){ Person[i].cards[j] = 10; cin&gt;&gt;c; }else Person[i].cards[j] = c-'0'; } Person[i].caculate(); } sort(Person,Person+n); for(int i = 0;i&lt;n;i++){ cout&lt;&lt;Person[i].name&lt;&lt;\"\\n\"; } }} C - 公园的长凳题目描述SDUQD 旁边的滨海公园有 x 条长凳。第 i 个长凳上坐着 a_i 个人。这时候又有 y 个人将来到公园，他们将选择坐在某些公园中的长凳上，那么当这 y 个人坐下后，记k = 所有椅子上的人数的最大值，那么k可能的最大值mx和最小值mn分别是多少。 输入第一行包含一个整数 x (1 &lt;= x &lt;= 100) 表示公园中长椅的数目第二行包含一个整数 y (1 &lt;= y &lt;= 1000) 表示有 y 个人来到公园接下来 x 个整数 a_i (1&lt;=a_i&lt;=100)，表示初始时公园长椅上坐着的人数 输出输出 mn 和 mx 题目分析 记录最大值和总人数即可 mn：min（（y+总人数-最大值*x）/x，最大值） mx：最大值+y 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int a[100];int main(){ int x,y,mx = 0; cin&gt;&gt;x&gt;&gt;y; for(int i = 1;i&lt;=x;i++){ cin&gt;&gt;a[i]; mx = max(mx,a[i]); } int res = 0; for(int i = 1;i&lt;=x;i++){ res += mx - a[i]; } if(y &gt; res){ cout&lt;&lt;ceil((y-res)/(double)x)+mx &lt;&lt;\" \"&lt;&lt; y+mx; }else { cout&lt;&lt;mx &lt;&lt;\" \"&lt;&lt; mx+y; } return 0;}","link":"/2020/05/07/程设Week9-作业/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","link":"/tags/CodeForces/"},{"name":"deep learning","slug":"deep-learning","link":"/tags/deep-learning/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"可视化","slug":"可视化","link":"/tags/可视化/"},{"name":"项目开发","slug":"项目开发","link":"/tags/项目开发/"},{"name":"词云","slug":"词云","link":"/tags/词云/"},{"name":"Mysql wsl vscode 踩坑记","slug":"Mysql-wsl-vscode-踩坑记","link":"/tags/Mysql-wsl-vscode-踩坑记/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"mobx","slug":"mobx","link":"/tags/mobx/"},{"name":"安全","slug":"安全","link":"/tags/安全/"},{"name":"综合评价方法","slug":"综合评价方法","link":"/tags/综合评价方法/"},{"name":"主成分分析","slug":"主成分分析","link":"/tags/主成分分析/"},{"name":"元胞自动机","slug":"元胞自动机","link":"/tags/元胞自动机/"},{"name":"社会力学模型","slug":"社会力学模型","link":"/tags/社会力学模型/"},{"name":"仿真模拟","slug":"仿真模拟","link":"/tags/仿真模拟/"},{"name":"线性规划","slug":"线性规划","link":"/tags/线性规划/"},{"name":"优化问题","slug":"优化问题","link":"/tags/优化问题/"},{"name":"一维搜索方法","slug":"一维搜索方法","link":"/tags/一维搜索方法/"},{"name":"梯度方法","slug":"梯度方法","link":"/tags/梯度方法/"},{"name":"牛顿法","slug":"牛顿法","link":"/tags/牛顿法/"},{"name":"因子分析","slug":"因子分析","link":"/tags/因子分析/"},{"name":"数学建模","slug":"数学建模","link":"/tags/数学建模/"},{"name":"时间序列","slug":"时间序列","link":"/tags/时间序列/"},{"name":"ARIMA模型","slug":"ARIMA模型","link":"/tags/ARIMA模型/"},{"name":"多维搜索方法","slug":"多维搜索方法","link":"/tags/多维搜索方法/"},{"name":"梯度下降法","slug":"梯度下降法","link":"/tags/梯度下降法/"},{"name":"聚类分析","slug":"聚类分析","link":"/tags/聚类分析/"},{"name":"浏览器","slug":"浏览器","link":"/tags/浏览器/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"思维题","slug":"思维题","link":"/tags/思维题/"},{"name":"单调队列优化","slug":"单调队列优化","link":"/tags/单调队列优化/"},{"name":"矩阵优化","slug":"矩阵优化","link":"/tags/矩阵优化/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"剪枝","slug":"剪枝","link":"/tags/剪枝/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"网络流24题","slug":"网络流24题","link":"/tags/网络流24题/"},{"name":"最小路径覆盖","slug":"最小路径覆盖","link":"/tags/最小路径覆盖/"},{"name":"二分图","slug":"二分图","link":"/tags/二分图/"},{"name":"dinic","slug":"dinic","link":"/tags/dinic/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"开发","slug":"开发","link":"/tags/开发/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"http缓存","slug":"http缓存","link":"/tags/http缓存/"},{"name":"区间dp","slug":"区间dp","link":"/tags/区间dp/"},{"name":"枚举","slug":"枚举","link":"/tags/枚举/"},{"name":"单调栈","slug":"单调栈","link":"/tags/单调栈/"},{"name":"单调队列","slug":"单调队列","link":"/tags/单调队列/"},{"name":"two pointers","slug":"two-pointers","link":"/tags/two-pointers/"},{"name":"前缀和与差分","slug":"前缀和与差分","link":"/tags/前缀和与差分/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"树的直径","slug":"树的直径","link":"/tags/树的直径/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"最小生成森林","slug":"最小生成森林","link":"/tags/最小生成森林/"},{"name":"最短路","slug":"最短路","link":"/tags/最短路/"},{"name":"差分约束","slug":"差分约束","link":"/tags/差分约束/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"Kosaraju","slug":"Kosaraju","link":"/tags/Kosaraju/"},{"name":"缩点","slug":"缩点","link":"/tags/缩点/"},{"name":"尺取","slug":"尺取","link":"/tags/尺取/"},{"name":"二分+前缀和","slug":"二分-前缀和","link":"/tags/二分-前缀和/"}],"categories":[{"name":"刷题","slug":"刷题","link":"/categories/刷题/"},{"name":"learning","slug":"learning","link":"/categories/learning/"},{"name":"程序设计思维与实践","slug":"程序设计思维与实践","link":"/categories/程序设计思维与实践/"},{"name":"前端学习","slug":"前端学习","link":"/categories/前端学习/"},{"name":"可视化","slug":"可视化","link":"/categories/可视化/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"数学建模","slug":"数学建模","link":"/categories/数学建模/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"visualization","slug":"visualization","link":"/categories/visualization/"}]}